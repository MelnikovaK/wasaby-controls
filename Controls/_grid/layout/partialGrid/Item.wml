<ws:template name="itemActionsTemplateChooser">
    <ws:if data="{{itemData.isSwiped}}">
        <ws:partial template="{{swipeTemplate}}"
                    itemData="{{itemData}}"
                    itemActionsTemplate="{{itemActionsTemplate}}"
                    itemActionsContainerStyles="{{itemActionsContainerStyles}}"
                    highlightOnHover="{{highlightOnHover}}"/>
    </ws:if>
    <ws:else data="{{itemData.itemActionsPosition !== 'custom'}}">
        <ws:partial template="{{itemActionsTemplate}}"
                    itemActionsClass="{{itemActionsClass}}"
                    itemData="{{itemData}}"
                    itemActionsContainerStyles="{{itemActionsContainerStyles}}"
                    attr:class="controls-Grid__itemAction"
                    highlightOnHover="{{highlightOnHover}}"/>
    </ws:else>
</ws:template>

<ws:template name="columnContent">
    <ws:if data="{{itemData.hasMultiSelect && currentColumn.columnIndex === 0}}">
        <ws:partial template="{{multiSelectTpl}}" attr:class="{{itemData.multiSelectClassList}}">
            <ws:templateOptions multiSelectStatus="{{itemData.multiSelectStatus}}" key="{{itemData.key}}" checkboxReadOnly="{{checkboxReadOnly}}"/>
        </ws:partial>
    </ws:if>
    <ws:else>
        <ws:if data="{{colspan}}">
            <ws:partial template="{{colspanTemplate}}" itemData="{{itemData}}"/>
        </ws:if>
        <ws:else>
            <ws:partial template="{{currentColumn.template}}"
                        editArrowTemplate="{{editArrowTemplate}}"
                        ladderWrapper="{{currentColumn.ladderWrapper}}"
                        attr:class="{{currentColumn.column.align ? ' controls-Grid__row-cell__content_halign_' + currentColumn.column.align : ''}}
                             {{itemData.isRightSwiped ? ' controls-ListView__item_rightSwipeAnimation'}}
                             {{currentColumn.column.valign ?' controls-Grid__cell_valign_' + currentColumn.column.valign + ' controls-Grid__cell-content_full-height' : ''}}"
                        itemData="{{currentColumn}}"/>
        </ws:else>
    </ws:else>
    <ws:if data="{{!itemData.columnScroll && itemData.isDrawActions(itemData, currentColumn, colspan)}}">
        <ws:partial template="itemActionsTemplateChooser"/>
    </ws:if>
</ws:template>

<ws:template name="columnContentWrapper">
    <ws:if data="{{itemData.shouldDrawMarker(marker, currentColumn.columnIndex)}}">
        <div attr:class="{{itemData.getMarkerClasses(itemData.rowSeparatorVisibility)}}"></div>
    </ws:if>
    <ws:partial template="columnContent" attr:class="{{currentColumn.hiddenForLadder ? 'controls-Grid__row-cell__content_hiddenForLadder'}}"/>
</ws:template>

<ws:template name="colTpl">
    <ws:if data="{{ itemData.columnScroll && itemData.isDrawActions(itemData, currentColumn, colspan) && itemData.itemActionsDrawPosition === 'before' }}">
        <ws:partial template="itemActionsTemplateChooser" itemActionsContainerStyles="{{currentColumn.gridCellStyles}}"/>
    </ws:if>
    <ws:if data="{{itemData.columnScroll && colspan}}">
        <div attr:class="{{currentColumn.cellClasses}}{{!!itemData.isActive && highlightOnHover !== false ? ' controls-GridView__item_active_theme-' + _options.theme}}{{!!itemData.isDragging ? ' controls-ListView__item_dragging'}} js-controls-SwipeControl__actionsContainer"
             attr:style="{{currentColumn.gridCellStyles}} {{itemData.getCellStyle(itemData, currentColumn, false)}} {{itemData.getColspanForColumnScroll().fixedColumns}}">
            <ws:partial template="columnContentWrapper"/>
        </div>
        <div attr:class="{{currentColumn.cellClasses}} {{!!itemData.isActive && highlightOnHover !== false ? ' controls-GridView__item_active_theme-' + _options.theme}} {{!!itemData.isDragging ? ' controls-ListView__item_dragging'}} js-controls-SwipeControl__actionsContainer"
             attr:style="{{currentColumn.gridCellStyles}} {{itemData.getCellStyle(itemData, currentColumn, false)}} {{itemData.getColspanForColumnScroll().scrollableColumns}}"></div>
    </ws:if>
    <ws:else>
        <div attr:class="{{currentColumn.cellClasses}}{{!!itemData.isActive && highlightOnHover !== false ? ' controls-GridView__item_active_theme-' + _options.theme}}{{!!itemData.isDragging ? ' controls-ListView__item_dragging'}} js-controls-SwipeControl__actionsContainer"
             attr:style="{{currentColumn.gridCellStyles + itemData.getCellStyle(itemData, currentColumn, colspan)}}">
            <ws:partial template="columnContentWrapper"/>
        </div>
    </ws:else>
    <ws:if data="{{ itemData.columnScroll && itemData.isDrawActions(itemData, currentColumn, colspan) && itemData.itemActionsDrawPosition === 'after' }}">
        <ws:partial template="itemActionsTemplateChooser" itemActionsContainerStyles="{{ currentColumn.itemActionsGridCellStyles }}"/>
    </ws:if>
</ws:template>

<ws:template name="partialGridSupportItem">
    <!-- When using a custom item template, the scope of the base template becomes the same as the scope of custom template.-->
    <!-- Because of this, the base handlers are lost.-->
    <!-- To fix this, need to remember the handlers where the scope is still right and set them. -->
    <!-- But current event system prevent do this, because it looks for given event handler only on closest control (which can -->
    <!-- be Browser, Explorer or smth else because of template scope). -->
    <!-- Therefore it is required to create Cell as control with and subscribe on events in it. -->
    <!-- https://online.sbis.ru/opendoc.html?guid=9d0f8d1a-576d-471d-bf02-991cd02f92e4 -->
    <Controls._grid.layout.partialGrid.Cell
            eventHandlers="{{itemData.handlersForPartialSupport}}"
            itemData="{{ itemData }}"
            attr:style="{{currentColumn.gridCellStyles + itemData.getCellStyle(itemData, currentColumn, colspan || colspanCurrentNode)}}"
            currentColumn="{{ currentColumn }}"
            clickable="{{ clickable }}"
            highlightOnHover="{{ highlightOnHover }}">
        <ws:columnContentTpl>
            <ws:partial template="colTpl" itemData="{{itemData}}" colspanTemplate="{{colspanTemplate}}" colspan="{{colspan}}" currentColumn="{{currentColumn}}" attr:class="{{className}}"/>
        </ws:columnContentTpl>
    </Controls._grid.layout.partialGrid.Cell>
</ws:template>


<ws:if data="{{itemData.styleLadderHeading}}">
    <div class="controls-Grid__row-ladder-cell {{itemData.getItemColumnCellClasses(itemData)}} js-controls-SwipeControl__actionsContainer
                {{!!itemData.isActive ? ' controls-GridView__item_active_theme-' + _options.theme}}
                {{!!itemData.isDragging ? ' controls-ListView__item_dragging'}}"
         style="{{itemData.styleLadderHeading}}">
        <ws:partial template="columnContent" currentColumn="{{itemData.getCurrentColumn()}}" attr:class="controls-Grid__row-ladder-cell__content"/>
    </div>
</ws:if>

<!-- Строка в режиме редактирования  -->
<ws:if data="{{itemData.isEditing}}">
    <div style="{{itemData.getEditingRowStyles()}}">
        <ws:for data="itemData.resetColumnIndex(); itemData.hasNextColumn(colspan); itemData.goToNextColumn();">
            <!-- To avoid closures, need to give all generating in itemData as a template options. -->
            <!-- For-loop creates it's own scope. In for scope itemData is always the same object. -->
            <!-- The template engine first builds the first level templates located in the body of the loop and does not enter them. -->
            <!-- Then it begins to build sub templates, for-iteration has been ended, so iterator will always give last column. -->
            <ws:partial template="partialGridSupportItem"
                        currentColumn="{{itemData.getCurrentColumn()}}"
                        attr:key="{{itemData.key}}_{{itemData.getCurrentColumnKey()}}"
                        itemData="{{itemData}}" />
        </ws:for>
    </div>
</ws:if>

<!-- Строка в режиме просмотра -->
<ws:else>
    <ws:for data="itemData.resetColumnIndex(); itemData.hasNextColumn(colspan); itemData.goToNextColumn();">
        <!-- To avoid closures, need to give all generating in itemData as a template options. -->
        <!-- For-loop creates it's own scope. In for scope itemData is always the same object. -->
        <!-- The template engine first builds the first level templates located in the body of the loop and does not enter them. -->
        <ws:partial
                template="partialGridSupportItem"
                currentColumn="{{itemData.getCurrentColumn()}}"
                itemData="{{itemData}}"
                colspan="{{colspan}}"
                colspanTemplate="{{colspanTemplate}}"
                attr:key="{{itemData.key}}_{{itemData.getCurrentColumnKey()}}" />
    </ws:for>
</ws:else>
