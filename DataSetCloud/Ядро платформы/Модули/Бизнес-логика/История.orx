<?xml version="1.0" encoding="WINDOWS-1251" ?>
<repository orx_version="1.71">

  <object last_changed="Ткачук М.И." name="История" responsible="Ткачук М.И.">
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." module_api_part="1" name="История.History_Last_Changed" responsible="Желдокас С.А." returns="TABLE" type="PYTHON">
      <parameter name="_filter">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="id">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="name">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>import sbis

if 'object' in _filter and _filter.object != None and _filter.object != '':

   client_id = sbis.Session.ClientID()
   site_host = sbis.Session.Get( sbis.WebServerContextKey.icsHOST )
   site_adm = sbis.Config.Instance().Get( 'СервисАдминистрирования.Адрес' )

   _filter.CopyOwnFormat()
   _filter.AddString( 'site_adm', site_adm )
   _filter.AddString( 'site_host', site_host )
   _filter.AddInt32( 'client', client_id )

   # получаем итоговую выборку
   obj_h = sbis.BLObject( 'History', 'СервисИстории' )
   subj_id_arr = obj_h.Invoke( 'Last_Changed', _filter )

   # вычисляем имя пользователя
   if subj_id_arr:
      subj_id_str = '{' + ",".join( str( id ) for id in subj_id_arr ) + '}'

      query = """ SELECT            "Имя" AS "name",
                          "@Пользователь" AS "id"
   
                  FROM    "Пользователь"
   
                  WHERE   "@Пользователь" = ANY ( '{subject_id}'::integer[] ) """.format( subject_id = subj_id_str )
   
      result = sbis.SqlQuery( query )
   
      return result

return None</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." module_api_part="1" name="История.History_Of_Documents_Last_Change" responsible="Желдокас С.А." returns="TABLE" type="PYTHON">
      <parameter name="ВремяДо">
        <format>
          <type>DATETIME</type>
        </format>
      </parameter>
      <parameter name="ВремяОт">
        <format>
          <type>DATETIME</type>
        </format>
      </parameter>
      <parameter name="Объекты">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <parameter name="Действие">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <return name="_object_id">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="_action">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="_time">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>"""
Параметры
   ВремяДо  - тип: Дата и Время ...самое позднее время фильтра
   ВремяОт  - тип: Дата и Время ...самое раннее время фильтра
   Объекты  - тип: Массив строк ...имена объектов
   Действие - тип: Массив строк ...название действий( Создание, Удаление, Изменение )

   {'ВремяОт':"2014-10-10", 'ВремяДо':"2014-12-29", 'Объекты':[ "Пользователь", "Сотрудники" ], 'Действие': [ 'Удаление', 'Изменение' ] }


Возвращает таблицу с полями
   _object_id   - тип: Число ...id экземпляра объекта
   _action      - тип: Строка ...действие
   _time        - тип: Дата и Время ...время действия

В связи с тем, что время на серверах немного различается, метод, при запросе изменений, созданных по текущее время, возвращает
записи, созданные не позднее двух минут назад, т.е. мы отрезаем две минуты от текущего времени, так как нет уверенности,
что за этот период вернутся все сообщения истории. Но, запрос, имеющий временнОй фильтр раньше чем текущее время минус 2 мин
будет возвращен полностью.

"""

_filter = Record()

client_id = sbis.Session.ClientID()
site_host = sbis.Session.Get( WebServerContextKey.icsHOST )
site_adm = sbis.Config.Instance().Get( 'СервисАдминистрирования.Адрес' )

_filter.AddString( 'СайтАдм', site_adm )
_filter.AddString( 'СайтХост', site_host )
_filter.AddInt32( 'Клиент', client_id )
_filter.AddDateTime( 'ВремяОт', ВремяОт )
_filter.AddDateTime( 'ВремяДо', ВремяДо )

_filter.AddArrayString( 'Действие' )
_filter.Действие = Действие

_filter.AddArrayString( 'Объекты' )
_filter.Объекты = Объекты

obj_h = BLObject( 'History', 'СервисИстории' )
result = obj_h.Invoke( 'List_For_Documents', _filter )

return result</body>
      </definition>
    </select>
    <standart_select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.History_Of_Instance" responsible="Желдокас С.А." type="PYTHON">
      <return name="_time">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="_real_time">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="_message">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="_subject_id">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="_ip_inner">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="_subject_name">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>import sbis

recs_on_page = Навигация.RecsOnPage()
page_number = Навигация.Page()

result = История.Of_History_Service( Фильтр, 'History_Of_Instance', recs_on_page, page_number )

mlr = MethodListResult()
mlr.nav_result = NavigationResult( result.is_next )
mlr.cursor = result.result.Cursor()

return mlr</body>
      </definition>
      <std_parameter filter_category="USER" name="Объект" param_type="OPTIONAL" type="TEXT[]"/>
      <std_parameter filter_category="USER" name="ИдО" param_type="REQUIRED" type="INTEGER"/>
      <std_parameter filter_category="USER" name="ВремяОтсчета" param_type="OPTIONAL" type="DATETIME"/>
      <std_parameter filter_category="USER" name="ВремяОт" param_type="OPTIONAL" type="DATETIME"/>
      <std_parameter filter_category="USER" name="ВремяДо" param_type="OPTIONAL" type="DATETIME"/>
    </standart_select>
    <standart_select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.History_Of_Object" responsible="Желдокас С.А." type="PYTHON">
      <return name="_time">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="_real_time">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="_message">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="_subject_id">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="_ip_inner">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="_subject_name">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>import sbis

recs_on_page = Навигация.RecsOnPage()
page_number = Навигация.Page()

result = История.Of_History_Service( Фильтр, 'History_Of_Object', recs_on_page, page_number )

mlr = MethodListResult()
mlr.nav_result = NavigationResult( result.is_next )
mlr.cursor = result.result.Cursor()

return mlr</body>
      </definition>
      <std_parameter filter_category="USER" name="Объект" param_type="REQUIRED" type="TEXT"/>
      <std_parameter filter_category="USER" name="ВремяОтсчета" param_type="OPTIONAL" type="DATETIME"/>
      <std_parameter filter_category="USER" name="ВремяОт" param_type="OPTIONAL" type="DATETIME"/>
      <std_parameter filter_category="USER" name="ВремяДо" param_type="OPTIONAL" type="DATETIME"/>
    </standart_select>
    <standart_select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.History_Of_Object_Last_Change" responsible="Желдокас С.А." type="PYTHON">
      <return name="_object_id">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="_object_name">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="_action">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="_time">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="_real_time">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="_subject_id">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="_ip_inner">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="_subject_name">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="_history_object">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>from method_register import MethodRegister

recs_on_page = Навигация.RecsOnPage()
page_number = Навигация.Page()

result = История.Of_History_Service( Фильтр, 'History_Of_Object_Last_Change', recs_on_page, page_number )

history_object_name_list = Фильтр.Объект

for history_object_name in history_object_name_list:
   unknown_obj_list = []

   for rec in result.result:
      if not rec._object_name and history_object_name == rec._history_object:
         unknown_obj_list.append( rec._object_id )

   if unknown_obj_list:
      method_name = MethodRegister.get_method( history_object_name )
      prefix = ''

      if method_name:

         method_name_list = method_name.split( '.' )
         bl_object = method_name_list[ 0 ]
         name_method = method_name_list[ 1 ]

         obj = BLObject( bl_object )
         result_double = obj.Invoke( name_method, unknown_obj_list )

         if result_double:

            table_object_name = result_double.names_table

            # инициализируем неизвестные экземпляры объекта на сервисе истории
            client_id = Session.ClientID()
            obj_h = BLObject( 'History', 'СервисИстории' )
            obj_h.AsyncInvoke( 'Initialize_Objects', table_object_name, client_id, history_object_name )

            prefix = result_double.prefix

            dict_name = dict.fromkeys( unknown_obj_list )


            if len( table_object_name ):
               for rec in table_object_name:
                  dict_name[ rec.object_id ] = rec.object_name

            for rec in result.result:
               if not rec._object_name and history_object_name == rec._history_object:
                  if dict_name[ rec._object_id ]:
                     rec._object_name = dict_name[ rec._object_id ]
                  else:
                     rec._object_name = prefix + str( rec._object_id )

      if not prefix:
         for rec in result.resultand and history_object_name == rec._history_object:
            if not rec._object_name:
               rec._object_name = 'Неопределенный объект ' + str( rec._object_id )


mlr = MethodListResult()
mlr.nav_result = NavigationResult( result.is_next )
mlr.cursor = result.result.Cursor()

return mlr</body>
      </definition>
      <std_parameter filter_category="USER" name="Объект" param_type="OPTIONAL" type="TEXT[]"/>
      <std_parameter filter_category="USER" name="ВремяОтсчета" param_type="OPTIONAL" type="DATETIME"/>
      <std_parameter filter_category="USER" name="ВремяОт" param_type="OPTIONAL" type="DATETIME"/>
      <std_parameter filter_category="USER" name="ВремяДо" param_type="OPTIONAL" type="DATETIME"/>
    </standart_select>
    <select access_mode="0" is_service="1" last_changed="Желдокас С.А." name="История.History_Subject_Name" responsible="Желдокас С.А." returns="TABLE" type="PYTHON">
      <parameter name="subject_id_arr">
        <format>
          <type>INT4[]</type>
        </format>
      </parameter>
      <return name="name">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="id">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>if subj_id_arr:
   subj_id_str = '{' + ",".join( str( id ) for id in subj_id_arr ) + '}'

query = """ SELECT            "Имя" AS "name"
                    "@Пользователь" AS "id"

            FROM    "Пользователь"

            WHERE   "@Пользователь" = ANY ( '{subject_id}'::integer[] ) """.format( subj_id_str )

result = SqlQuery( query )

return result</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.Of_History_Service" responsible="Желдокас С.А." returns="RECORD" type="PYTHON">
      <parameter name="_filter">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <parameter name="of_method">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="recs_on_page">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="page_number">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <return name="result">
        <format>
          <type>RECORDSET</type>
        </format>
      </return>
      <return name="is_next">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>import sbis

def get_Subject_Name( subject_id ):
   subject_name = sbis.SqlQueryScalar( """
                           SELECT  "Имя"

                           FROM
                                   "Пользователь"
                           WHERE
                                   "@Пользователь" = $1 """, subject_id )
   return subject_name

client_id = sbis.Session.ClientID()
site_host = sbis.Session.Get( sbis.WebServerContextKey.icsHOST )
site_adm = sbis.Config.Instance().Get( 'СервисАдминистрирования.Адрес' )

_filter.CopyOwnFormat()
_filter.AddString( 'СайтАдм', site_adm )
_filter.AddString( 'СайтХост', site_host )
_filter.AddInt32( 'Клиент', client_id )

# получаем итоговую выборку
obj_h = sbis.BLObject( 'History', 'СервисИстории' )
result = obj_h.Invoke( 'List', of_method, _filter, recs_on_page, page_number )

# вычисляем имя пользователя
cache_of_subject = dict()
for rec in result.result:
   cache_key = str( rec._subject_id )
   if cache_key in cache_of_subject:
      rec._subject_name = cache_of_subject[ cache_key ]
   else:
      user_name = get_Subject_Name( rec._subject_id )
      if user_name:
         rec._subject_name = get_Subject_Name( rec._subject_id )
         cache_of_subject[ cache_key ] = rec._subject_name
      else:
         undefined_name = "Неопределенный пользователь " + cache_key
         rec._subject_name = undefined_name
         cache_of_subject[ cache_key ] = undefined_name

return result</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Мирзоян Г.Ю." name="История.ЕстьСотрудник" responsible="Буравлев М.С." returns="SCALAR" type="PYTHON">
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return hasattr( Пользователь, 'СвязьПользователя' )</body>
      </definition>
    </select>
    <select access_mode="0" is_service="1" last_changed="Буравлев М.С." name="История.ЗарегистрироватьКонтекст" responsible="Ткачук М.И." returns="SCALAR" type="PYTHON">
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>filter = lambda param, field, quote: str( field + " = "  + quote + str( param ) + quote ) if param is not None else str( field + " is null " )
# Получить контекст исполнения
_uid = Session.UserID()
_ipe = Session.ExternalIP() or "::1"
_ipi = Session.InternalIP()
if _ipi == "0.0.0.0":
   _ipi = None
_subj = Session.Get(WebServerContextKey.icsX_SUBJECT) or ""
_session = Session.ID() or ""
query = """ select "@$Пользователь" from "log.$Пользователь" 
   where """ + filter( _uid, """ "Пользователь" """, "" ) + " and " + filter( _ipe, """ "IP" """, "'" ) + " and " + filter( _ipi, """ "IPВнутренний" """, "'" ) + " and " + filter( _subj, """ "Субъект" """, "'" ) + " limit 1"
logUserId = SqlQueryScalar( query )
if logUserId is None:
   rs = SqlQuery( """insert into "log.$Пользователь" values(default) returning "@$Пользователь" as log_user_id""" )
   logUserId = rs[0].log_user_id

check = SqlQueryScalar( """ SELECT EXISTS ( SELECT 1 FROM "log.$Изменение" WHERE "Транзакция" = txid_current() AND "Предок" = $1 ) """,logUserId )
if check:
   rs = SqlQuery( """insert into "log.$Изменение"( "Таблица" ) values( '"ИсторияПользовательскоеСобытие"'::regclass ) returning "@$Изменение" as changing_id""" )
else:
   rs = SqlQuery( """insert into "log.$Изменение"( "Таблица", "Предок" ) values( '"ИсторияПользовательскоеСобытие"'::regclass, {parent_id} ) returning "@$Изменение" as changing_id""".format( parent_id = logUserId ) )

return rs[0].changing_id</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.ЗарегистрироватьСобытие" responsible="Ткачук М.И." returns="NONE" type="PYTHON">
      <parameter name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>if ( Сообщение and Действие ) is None:
   raise ValueError( 'Параметры метода регистрации события истории должны быть заполнены!' )
with CreateTransaction( TransactionLevel.READ_COMMITTED, TransactionMode.WRITE ):
   message = Сообщение
   eventName = Действие.lower()
   # Получить ID из таблица ИсторияДействие
   eventId = SqlQueryScalar( """select "@ИсторияДействие" from "ИсторияДействие" where "Действие" = $1 """, eventName )
   # Если действие не зарегистрировано, то добавляем и возвращаем ID
   if eventId is None:
      rs = SqlQuery( """insert into "ИсторияДействие"( "Действие" ) values( $1 ) returning "@ИсторияДействие" as event_id""", eventName )
      eventId = rs[0].event_id
   # Получить контекст исполнения
   context_id = История.ЗарегистрироватьКонтекст()
   # Зарегистрировать событие
   SqlQuery( """insert into "ИсторияПользовательскоеСобытие"( "Сообщение", "Действие", "КонтекстИсполнения", "Когда" ) 
      values( $1, $2, $3, current_timestamp )""", message, eventId, context_id )</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.ЗарегистрироватьСобытие" responsible="Ткачук М.И." returns="NONE" type="PYTHON">
      <parameter name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Объект">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ИдентификаторОбъекта">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>if ( Сообщение and Действие and Объект and ИдентификаторОбъекта) is None:
   raise ValueError( 'Параметры метода регистрации события истории должны быть заполнены!' )
with CreateTransaction( TransactionLevel.READ_COMMITTED, TransactionMode.WRITE ):
   message = Сообщение
   eventName = Действие.lower()
   objectName = Объект.lower()

   # Получить ID из таблица ИсторияДействие
   eventId = SqlQueryScalar( """select "@ИсторияДействие" from "ИсторияДействие" where "Действие" = $1 """, eventName )

   # Если действие не зарегистрировано, то добавляем и возвращаем ID
   if eventId is None:
      rs = SqlQuery( """insert into "ИсторияДействие"( "Действие" ) values( $1 ) returning "@ИсторияДействие" as event_id""", eventName )
      eventId = rs[0].event_id

   # Получить контекст исполнения
   context = История.ЗарегистрироватьКонтекст()

   # Получаем/регистрируем объект
   # Получить ID из таблица ИсторияДействие
   objectId = SqlQueryScalar( """select "@ИсторияОбъект" from "ИсторияОбъект" where "Объект" = $1 """, objectName )

   # Если действие не зарегистрировано, то добавляем и возвращаем ID
   if objectId is None:
      rs = SqlQuery( """insert into "ИсторияОбъект"( "Объект" ) values( $1 ) returning "@ИсторияОбъект" as object_id""", objectName )
      objectId = rs[0].object_id

   # Зарегистрировать событие
   SqlQuery( """insert into "ИсторияПользовательскоеСобытие"( "Сообщение", "Действие", "КонтекстИсполнения", "Когда", "Объект", "ИдентификаторОбъекта" ) 
      values( $1, $2, $3, current_timestamp, $4, $5 )""", message, eventId, context, objectId, ИдентификаторОбъекта or -1 )</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Буравлев М.С." name="История.Контекст" responsible="Буравлев М.С." returns="TABLE" type="SQL">
      <parameter name="Контекст">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <return name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Субъект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="IP">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="IPВнутренний">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="РабочееМесто">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>select
	"Пользователь",
	"Субъект",
	host( "IP" ) as "IP",
	host( "IPВнутренний" ) as "IPВнутренний",
	"ИмяХоста" as "РабочееМесто"
from
	"log.$Пользователь"
where
	"@$Пользователь" = :Контекст</body>
      </definition>
    </select>
    <standart_select access_mode="0" is_proxy="0" is_service="0" last_changed="Желдокас С.А." name="История.Список" responsible="Буравлев М.С." type="NATIVE">
      <return name="РеальноеВремя">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="Время">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Объект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Пользователь">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Контекст">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Транзакция">
        <format>
          <type>INT64</type>
        </format>
      </return>
      <std_parameter filter_category="USER" name="ТолькоИзмененные" param_type="OPTIONAL" type="BOOLEAN"/>
      <std_parameter filter_category="USER" name="ИдО" param_type="REQUIRED" type="INT64"/>
      <std_parameter filter_category="USER" name="ВремяОт" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="ВремяДо" param_type="OPTIONAL" type="TEXT"/>
    </standart_select>
    <standart_select access_mode="0" is_service="1" last_changed="Ткачук М.И." name="История.СписокДействий" responsible="Ткачук М.И." type="PYTHON">
      <return name="ИдентификаторДействия">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return SqlQuery( """select "@ИсторияДействие" as "ИдентификаторДействия", "Действие" as "Действие" from "ИсторияДействие" """)</body>
      </definition>
    </standart_select>
    <standart_select access_mode="0" is_service="1" last_changed="Ткачук М.И." name="История.СписокОбъектов" responsible="Ткачук М.И." type="PYTHON">
      <return name="ИдентификаторОбъекта">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Объект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return SqlQuery( """select "@ИсторияОбъект" as "ИдентификаторОбъекта", "Объект" as "Объект" from "ИсторияОбъект" """)</body>
      </definition>
    </standart_select>
    <standart_select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.СписокПроизвольнойИстории" responsible="Ткачук М.И." type="PYTHON">
      <return name="Время">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Объект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="ИдентификаторОбъекта">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Логин">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Пользователя">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="КонтекстИсполнения">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Субъект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Транзакция">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body># Функция проверки задан фильтр или нет
# -------------------------------------
def TestFilter( filter, filterName ):
   if filter is not None and filter.TestField( filterName ) is not None and not filter[filterName].IsNull() and str( filter[filterName] ).strip() != "":
      return True
   return False
# Функция формирования условия where
# -------------------------------------
def MakeWhereClause( first, filter, query):
   if first:
      first = False
      query += """ where """ + filter
   else:
      query += """ and """ + filter
   return first, query
# Функция формирования параметра сортировки
# -------------------------------------
def MakeSortClause( query, sortParam ):
   if sortParam.fieldName == "Когда" or sortParam.fieldName == "Время":
      query += """ "Время" """
   if sortParam.order == SortOrder.soASCENDING:
      query += " asc "
   if sortParam.order == SortOrder.soDESCENDING:
      query += " desc "
   return query
# Тело выборки
# -------------------------------------
queryFields = """
select user_event."Когда" as "Время", 
   user_event."Сообщение" as "Сообщение", 
   event."Действие" as "Действие", 
   object."Объект" as "Объект", 
   user_event."ИдентификаторОбъекта" as "ИдентификаторОбъекта", 
   user_."Логин" as "Логин", 
   user_."@Пользователь" as "Пользователь", 
   user_."Имя" as "Имя", 
   log_user."@$Пользователь" as "КонтекстИсполнения",
   log_changing."Транзакция" as "Транзакция" """ 
queryTables = """ from "ИсторияПользовательскоеСобытие" user_event 
      join "ИсторияДействие" event on user_event."Действие" = event."@ИсторияДействие"       
      join "log.$Изменение" log_changing on user_event."КонтекстИсполнения" = log_changing."@$Изменение"  
      left join "log.$Пользователь" log_user on log_changing."Предок" = log_user."@$Пользователь"
      left join "Пользователь" user_ on log_user."Пользователь" = user_."@Пользователь"
      left join "ИсторияОбъект" object on user_event."Объект" = object."@ИсторияОбъект" """
# Фильтры
# -------------------------------------
filter = Фильтр
first = True
queryWhere = ""
if TestFilter( filter, 'ВремяОт' ):
   filterText = """ user_event."Когда" &gt;= '{date_begin_param}' """.format( date_begin_param = filter['ВремяОт'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'ВремяДо' ):
   filterText = """ user_event."Когда" &lt;= '{date_end_param}' """.format( date_end_param = filter['ВремяДо'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'КонтекстИсполнения' ):
   filterText = """ user_event."КонтекстИсполнения" = {context_param} """.format( context_param = filter['КонтекстИсполнения'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Объект' ):
   filterText = """ object."Объект" = '{object_param}' """.format( object_param = str( filter['Объект'] ).lower() )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Действие' ):
   filterText = """ event."Действие" = '{event_param}' """.format( event_param = str( filter['Действие'] ).lower() )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Субъект' ):
   filterText = """ log_user."Субъект" = '{subject_param}' """.format( subject_param = filter['Субъект'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Пользователь' ):
   filterText = """ log_user."Пользователь" = {user_param} """.format( user_param = filter['Пользователь'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )
   
if TestFilter( filter, 'Логин' ):
   filterText = """ user_."Логин" = '{user_login_param}' """.format( user_login_param = filter['Логин'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )
   
if TestFilter( filter, 'Имя' ):
   filterText = """ user_."Имя" = '{user_name_param}' """.format( user_name_param = filter['Имя'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Транзакция' ):
   filterText = """ log_changing."Транзакция" = {trans_param} """.format( trans_param = filter['Транзакция'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )
   
if TestFilter( filter, 'ИдентификаторОбъекта' ):
   filterText = """ user_event."ИдентификаторОбъекта" = {object_id_param} """.format( object_id_param = filter['ИдентификаторОбъекта'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Сообщение' ):
   filterText = """ user_event."Сообщение" ilike '%{message_param}%' """.format( message_param = filter['Сообщение'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

# Обработка параметров сортировки
# -------------------------------------
sort = Сортировка
querySort = ""
if sort and sort.size():
   querySort += " order by "
   for param in sort:
      querySort = MakeSortClause( querySort, param )
else:
   querySort += """ order by "Время" desc"""

# Выполнение запроса и формирование результата
# -------------------------------------
nav = Навигация
result = MethodListResult()

query = queryFields + queryTables + queryWhere + querySort
if not nav.IsNull():
   # Постраничная навигация по методу Есть ли еще
   if nav.IsNext():
      if nav.Page() &gt;= 0:
         query += """ offset """ + str ( nav.Page() * nav.RecsOnPage() )
         query += """ limit """ + str( nav.RecsOnPage() + 1 )

   # При переходе на последнюю страницу рассчитывается количество всех записей
   if not nav.IsNext() and nav.Page() == -1:
      queryCount = "select count(*) " + queryTables + queryWhere
      recordsCount = SqlQueryScalar( queryCount )
      result.nav_result = NavigationResult( recordsCount )
      offset = int( recordsCount / nav.RecsOnPage() )
      query += """ offset """ + str ( offset * nav.RecsOnPage() )
      query += """ limit """ + str( nav.RecsOnPage() )

   # Постраничная навигация с подсчетом результирующего числа записей
   if not nav.IsNext() and nav.Page() &gt;= 0:
      queryCount = queryCount = "select count(*) " + queryTables + queryWhere
      recordsCount = SqlQueryScalar( queryCount )
      result.nav_result = NavigationResult( recordsCount )
      query += """ offset """ + str ( nav.Page() * nav.RecsOnPage() )
      query += """ limit """ + str( nav.RecsOnPage() )

# Выполнение запроса
resultData = SqlQuery( query )

context_and_name = dict()
transaction = list()
for rec in resultData:
   if not rec.Имя:
      transaction.append( rec.Транзакция )
      context_and_name[ rec.Транзакция ] = 'Не определено'

query_context = """
               SELECT
                  log_changing."Транзакция" AS "Транзакция",
                  user_."Имя" AS "Имя",
                  user_."@Пользователь" AS "Пользователь",
                  user_."Логин" as "Логин",
                  log_user."@$Пользователь" as "КонтекстИсполнения"
               FROM
                  "log.$Изменение" log_changing
               LEFT JOIN
                  "log.$Пользователь" log_user
                           ON
                              log_changing."Предок" = log_user."@$Пользователь"
               LEFT JOIN
                  "Пользователь" user_
                           ON
                              log_user."Пользователь" = user_."@Пользователь"
               WHERE
                  log_changing."Транзакция" = ANY( '{array_transaction}'::bigint[] ) """.format( array_transaction = '{' + ",".join(str(v) for v in transaction) + '}' )
result_query_context = SqlQuery( query_context )

for rec in result_query_context:
   if rec.Имя:
      context_and_name[ rec.Транзакция ] = rec

for rec_ in resultData:
   if not rec_.Имя:
      data = context_and_name[ rec_.Транзакция ]
      if data != 'Не определено':
         rec_.Имя = data.Имя
         rec_.Пользователь = data.Пользователь
         rec_.Логин = data.Логин
         rec_.КонтекстИсполнения = data.КонтекстИсполнения
      else:
         rec_.Имя = data

# Постраничная навигация по методу Есть ли еще. Удаляем из результирующего набора лишнюю одну строку
if not nav.IsNull() and nav.IsNext():
   if resultData.Size() &gt; nav.RecsOnPage():
      result.nav_result = NavigationResult( True )
      resultData.DelRow( nav.RecsOnPage() )
   else:
      result.nav_result = NavigationResult( False )

result.cursor = resultData.Cursor()
return result</body>
      </definition>
      <std_parameter filter_category="USER" name="Транзакция" param_type="OPTIONAL" type="INTEGER"/>
      <std_parameter filter_category="USER" name="Субъект" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="Сообщение" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="Объект" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="Логин" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="КонтекстИсполнения" param_type="OPTIONAL" type="INTEGER"/>
      <std_parameter filter_category="USER" name="Имя" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="ИдентификаторПользователя" param_type="OPTIONAL" type="INTEGER"/>
      <std_parameter filter_category="USER" name="ИдентификаторОбъекта" param_type="OPTIONAL" type="INTEGER"/>
      <std_parameter filter_category="USER" name="Действие" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="ВремяОт" param_type="OPTIONAL" type="DATETIME"/>
      <std_parameter filter_category="USER" name="ВремяДо" param_type="OPTIONAL" type="DATETIME"/>
    </standart_select>
    <standart_select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.СписокСлужебный" responsible="Желдокас С.А." type="PYTHON">
      <return name="РеальноеВремя">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="Время">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Объект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Пользователь">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Контекст">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Транзакция">
        <format>
          <type>INT64</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>from historygetter import HistoryGetter
import re

def СписокСлужебныйАвтогенерируемойИстории( ДопПоля, Фильтр, Сортировка, Навигация ):

   frmt = MethodResultFormat('История.Список', 4)
   res = CreateRecordSet(frmt)
   recRes = Record(frmt)

   filter_for_change = Record()
   filter_for_change.AddArrayInt32("ИдСобытияСписок")
   filter_for_change.AddBool( "ТолькоНазванияПолей" )
   filter_for_change.AddBool( "ТолькоИзмененныеПоля" )
   #filter_for_change.ТолькоНазванияПолей = False
   filter_for_change.ТолькоИзмененныеПоля = Фильтр.ТолькоИзмененныеПоля if 'ТолькоИзмененныеПоля' in Фильтр else True

   transaction = 0
   history = HistoryGetter(Фильтр, Навигация)
   captions = history.get_history_headers()
   transactions_and_it_changes = dict()
   table_and_it_changes = dict()
   changes_by_table_in_transaction = dict()
   event_rs_by_transaction = dict()
   user_history_handler = Фильтр.ПользовательскийОбработчик

   if user_history_handler:
      user_history_handler = user_history_handler.replace('\n','\n   ')
      code = '''def fun( События ):\n   import historygetter\n   {code}\nout_ = fun( in_ )'''.format( code=user_history_handler )
      user_handler = compile( code, 'historyHandler', 'exec' )
   else:
      user_handler = None

   ### handle_transaction ##################################################################################################
   def handle_transaction( transaction_, transaction_details ):
      context = None

      for table_, table_info in transaction_details.items():
         if not context:
            context = table_info['context']
            break

      changes_in_transaction = event_rs_by_transaction[ transaction_ ]

      #Если присуствутет пользовательский метод обработки
      if user_history_handler:
         #ПользовательскоеПредставлениеТаблицыРолиПользователей( changes_in_transaction )
         locals_ = { 'in_' : changes_in_transaction }
         exec( user_handler, dict( globals() ), locals_ )

      first_record = True
      message = ''
      #Занести изменения в результирующий список записей
      if changes_in_transaction is not None:
         changes_in_transaction.SortRows(lambda rec_a, rec_b: ( rec_a.id and rec_a.id &gt; rec_b.id ) )
         for change in changes_in_transaction:
            if not first_record:
               message += '\r\n'

            message += HistoryGetter.get_message_by_data( change ) if not change.Сообщение else change.Сообщение
            message += '.'
            
            if first_record:
               recRes.Время = context.Время.replace( second=0, microsecond=0 )
               recRes.РеальноеВремя = context.Время
               recRes.Объект = context.Объект
               recRes.Пользователь = context.Пользователь
               recRes.Контекст = context.Контекст
               recRes.Имя = context.Имя
               recRes.Действие = change.Действие
               first_record = False

         if ( ( 'Сообщение' not in Фильтр or not Фильтр.Сообщение ) or re.search( Фильтр.Сообщение, message, re.I ) ) and changes_in_transaction.Size():
            recRes.Сообщение = message
            res.AddRow(recRes)
      #~newContext
   #~handle_transaction#################################################################################################

   for caption in captions:
      #чтобы первоначальную транзакцию инициализировать
      if transaction == 0:
         transaction = caption.Транзакция

      #определяем сменилась ли транзакция
      newContext = caption.Транзакция != transaction

      old_transaction = transaction
      #запоминаем транзакцию
      transaction = caption.Транзакция

      if newContext: #здесь вычисляем все записи, подобавляем и тд
         transactions_and_it_changes[ old_transaction ] = changes_by_table_in_transaction.copy()
         changes_by_table_in_transaction.clear()

      if caption.Таблица in changes_by_table_in_transaction:
         changes_by_table_in_transaction[caption.Таблица]['changes'].append( caption.id )
         #changes_by_table_in_transaction[caption.Таблица]['action'] = HistoryGetter.get_mixed_action( changes_by_table_in_transaction[caption.Таблица]['action'], caption.Действие )
      else:
         changes_by_table_in_transaction[caption.Таблица] = {
            'changes': [caption.id],
            'context': caption
            #'action': caption.Действие
         }

      if caption.Таблица in table_and_it_changes:
         table_and_it_changes[ caption.Таблица ].append( caption.id )
      else:
         table_and_it_changes[ caption.Таблица ] = [caption.id]

   transactions_and_it_changes[ transaction ] = changes_by_table_in_transaction.copy()
   changes_by_table_in_transaction.clear()

   rs_format = None

   for table, changes in table_and_it_changes.items():
      filter_for_change.ИдСобытияСписок = changes
      detailed_changes = HistoryGetter( filter_for_change )
      events_by_table = detailed_changes.get_events( table )

      for event in events_by_table:
         if not rs_format:
            rs_format = event.Format()

         tr = event.Транзакция
         if tr not in event_rs_by_transaction:
            event_rs_by_transaction[ tr ] = CreateRecordSet( rs_format )

         event_rs_by_transaction[ tr ].AddRow( event )

   for transaction, changes in transactions_and_it_changes.items():
      if transaction not in event_rs_by_transaction:
         continue
      handle_transaction( transaction, changes )

   return res
######################################################################################################################################################################################

def СписокСлужебныйПроизвольнойИстории( ДопПоля, Фильтр, Сортировка, Навигация ):
   # Функция проверки задан фильтр или нет
   # -------------------------------------
   def TestFilter( filter, filterName ):
      if filter is not None and filter.TestField( filterName ) is not None and not filter[filterName].IsNull() and str( filter[filterName] ).strip() != "":
         return True
      return False
   # Функция формирования условия where
   # -------------------------------------
   def MakeWhereClause( first, filter, query):
      if first:
         first = False
         query += """ where """ + filter
      else:
         query += """ and """ + filter
      return first, query
   # Функция формирования параметра сортировки
   # -------------------------------------
   def MakeSortClause( query, sortParam ):
      if sortParam.fieldName == "Когда" or sortParam.fieldName == "Время":
         query += """ "РеальноеВремя" """
      if sortParam.order == SortOrder.soASCENDING:
         query += " ASC "
      if sortParam.order == SortOrder.soDESCENDING:
         query += " DESC "
      return query

   # Получаем адрес сервиса с которого зашли
   # -------------------------------------
   site = ConfigGet( 'АдресСервиса' ).lower()
   site = site[ site.find( '://' ) + 3 : ]
   # Тело выборки
   # -------------------------------------
   queryFields = """
      SELECT         user_event."Когда" AS "РеальноеВремя",
                        NULL::timestamp AS "Время",
                 user_event."Сообщение" AS "Сообщение",
                       event."Действие" AS "Действие",
                        object."Объект" AS "Объект",
               CASE WHEN SUBSTRING( log_user."Субъект" FROM '#.+' ) = '#{site}'
                  THEN
                     log_user."Субъект"
                  ELSE
                     log_user."Пользователь"::text
                                    END AS "Пользователь",
                            user_."Имя" AS "Имя",
              log_user."@$Пользователь" AS "Контекст",
              log_changing."Транзакция" AS "Транзакция" """.format( site = site )

   queryTables = """
      FROM
         "ИсторияПользовательскоеСобытие" user_event
      JOIN
         "ИсторияДействие" event
      ON
         user_event."Действие" = event."@ИсторияДействие"
      JOIN
         "log.$Изменение" log_changing
      ON
         user_event."КонтекстИсполнения" = log_changing."@$Изменение"
      LEFT JOIN
         "log.$Пользователь" log_user
      ON
         log_changing."Предок" = log_user."@$Пользователь"
      LEFT JOIN
         "Пользователь" user_
      ON
         log_user."Пользователь" = user_."@Пользователь"
      LEFT JOIN
         "ИсторияОбъект" object
      ON
         user_event."Объект" = object."@ИсторияОбъект" """
   # Фильтры
   # -------------------------------------
   filter = Фильтр
   first = True
   queryWhere = ""
   if TestFilter( filter, 'ВремяОт' ):
      filterText = """ user_event."Когда" &gt;= '{date_begin_param}' """.format( date_begin_param = filter['ВремяОт'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'ВремяОтсчета' ):
      filterText = """ user_event."Когда" &lt; '{date_end_param}' """.format( date_end_param = filter['ВремяОтсчета'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )
   elif TestFilter( filter, 'ВремяДо' ):
      filterText = """ user_event."Когда" &lt; '{date_end_param}' """.format( date_end_param = filter['ВремяДо'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'КонтекстИсполнения' ):
      filterText = """ user_event."КонтекстИсполнения" = {context_param} """.format( context_param = filter['КонтекстИсполнения'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Объект' ):
      filterText = """ object."Объект" = '{object_param}' """.format( object_param = str( filter['Объект'] ).lower() )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'ИдО' ):
      filterText = """ user_event."ИдентификаторОбъекта" = '{object_param}' """.format( object_param = str( filter['ИдО'] ).lower() )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Действие' ):
      filterText = """ event."Действие" = '{event_param}' """.format( event_param = str( filter['Действие'] ).lower() )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Субъект' ):
      filterText = """ log_user."Субъект" = '{subject_param}' """.format( subject_param = filter['Субъект'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Пользователь' ):
      filterText = ( """ "Субъект" = '""" + str( filter['Пользователь'] ) + "'"  ) if '#' in str( filter['Пользователь'] ) else ( """ "Пользователь" = """ + str( filter['Пользователь'] ) )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Имя' ):
      filterText = """ user_."Имя" = '{user_name_param}' """.format( user_name_param = filter['Имя'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Сообщение' ):
      filterText = """ user_event."Сообщение" ILIKE '%$1%' """
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   # Обработка параметров сортировки
   # -------------------------------------
   sort = Сортировка
   querySort = ""
   if sort and sort.size():
      querySort += " ORDER BY "
      for param in sort:
         querySort = MakeSortClause( querySort, param )
   else:
      querySort += """ ORDER BY "РеальноеВремя" DESC"""

   # Выполнение запроса и формирование результата
   # -------------------------------------
   nav = Навигация
   query = queryFields + queryTables + queryWhere + querySort
   query += """ limit """ + str( nav.RecsOnPage() + 1 )

   # Выполнение запроса
   if TestFilter( filter, 'Сообщение' ):
      resultData = SqlQuery( query, filter.Сообщение )
   else:
      resultData = SqlQuery( query )

   context_and_name = dict()
   transaction = list()
   for rec in resultData:
      if not rec.Имя:
         transaction.append( rec.Транзакция )
         context_and_name[ rec.Транзакция ] = 'Не определено'

   query_context = """
                  SELECT
                     log_changing."Транзакция" AS "Транзакция",
                     user_."Имя" AS "Имя",
                     user_."@Пользователь" AS "Пользователь",
                     user_."Логин" as "Логин",
                     log_user."@$Пользователь" as "КонтекстИсполнения"
                  FROM
                     "log.$Изменение" log_changing
                  LEFT JOIN
                     "log.$Пользователь" log_user
                              ON
                                 log_changing."Предок" = log_user."@$Пользователь"
                  LEFT JOIN
                     "Пользователь" user_
                              ON
                                 log_user."Пользователь" = user_."@Пользователь"
                  WHERE
                     log_changing."Транзакция" = ANY( '{array_transaction}'::bigint[] ) """.format( array_transaction = '{' + ",".join(str(v) for v in transaction) + '}' )
   result_query_context = SqlQuery( query_context )

   for rec in result_query_context:
      if rec.Имя:
         context_and_name[ rec.Транзакция ] = rec

   for rec_ in resultData:
      rec_.Время = rec_.РеальноеВремя.replace( second=0, microsecond=0 )
      if not rec_.Имя:
         data = context_and_name[ rec_.Транзакция ]
         if data != 'Не определено':
            rec_.Имя = data.Имя
            rec_.Пользователь = str( data.Пользователь )
            rec_.Контекст = data.КонтекстИсполнения
         else:
            rec_.Имя = data

   return resultData
##############################################################################################################################################################################

def result_handler( result ):
   navi = False
   if result:
      # получаем метод сортировки получившейся таблицы
      sort = Сортировка
      if sort and sort.size():
         for sortParam in sort:
            if sortParam.fieldName == "Когда" or sortParam.fieldName == "Время":
               if sortParam.order == SortOrder.soASCENDING:
                  result.SortRows( lambda rec_a, rec_b: rec_a.РеальноеВремя &gt; rec_b.РеальноеВремя )## сортируем по времени результирующую таблицу по возрастанию
               else:
                  result.SortRows( lambda rec_a, rec_b: rec_a.РеальноеВремя &lt; rec_b.РеальноеВремя )## сортируем по времени результирующую таблицу по убыванию
      else:
         result.SortRows( lambda rec_a, rec_b: rec_a.РеальноеВремя &gt; rec_b.РеальноеВремя )
      nav = Навигация
      if not nav.IsNull() and ( result.Size() - nav.RecsOnPage() ) &gt; 0 :
         navi = True
         indexForDel = range( nav.RecsOnPage(), result.Size() )
         # удаляем ненужные записи, оставляя выборку запрашиваемой длинны
         for i in reversed( indexForDel ):
            result.DelRow( i )
   mlr = MethodListResult()
   mlr.cursor = result.Cursor()
   mlr.nav_result = NavigationResult( navi )
   return mlr
#################################################################################################################################################################################

# удаляем из строки фильтра лидирующие
if Фильтр.TestField( 'Сообщение' ) is not None and not Фильтр['Сообщение'].IsNull() and Фильтр.Сообщение.strip() != "":
   Фильтр.Сообщение = re.escape( Фильтр.Сообщение )

# слияние двух таблиц с равным форматом
autoHistory = СписокСлужебныйАвтогенерируемойИстории( ДопПоля, Фильтр, Сортировка, Навигация )
artHistory = СписокСлужебныйПроизвольнойИстории( ДопПоля, Фильтр, Сортировка, Навигация )

if autoHistory.Size():
   if artHistory.Size():
      for rec in artHistory:
         autoHistory.AddRow( rec )
   return result_handler( autoHistory )
else:
   return result_handler( artHistory )</body>
      </definition>
      <std_parameter filter_category="USER" name="ТолькоИзмененные" param_type="OPTIONAL" type="BOOLEAN"/>
      <std_parameter filter_category="USER" name="ИдО" param_type="REQUIRED" type="INT64"/>
      <std_parameter filter_category="USER" name="ВремяОт" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="ВремяДо" param_type="OPTIONAL" type="TEXT"/>
    </standart_select>
  </object>

</repository>
