<?xml version="1.0" encoding="WINDOWS-1251" ?>
<repository orx_version="1.71">

  <object last_changed="Буравлев М.С." name="History" responsible="Буравлев М.С.">
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="History.Get_List_Part" responsible="Желдокас С.А." returns="RECORD" type="PYTHON">
      <parameter name="_filter">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <parameter name="how_recs_return">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="id_db_in">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="from_method">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="result">
        <format>
          <type>RECORDSET</type>
        </format>
      </return>
      <return name="query">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="id_db">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>
from HistoryHelper import DBCarousel

from HistoryHelper import HistoryHelper
import sbis

class HistoryConstructor:
############################################################################################################################################

   def __init__(self, _filter, how_recs_return, id_db_in, from_method ):
      if id_db_in == None:
         raise Exception( 'Отсутствует идентификатор базы данных' )

      DBCarousel.set_ID_Current_DB( id_db_in )
      self.filter = _filter
      self.queryWhere = ''
      self.how_recs_return = how_recs_return
      self.db = id_db_in
      self.from_method = from_method
      self.condition_where_object = ''

      if 'Объект' in _filter:
         object_id_list = []
         for obj in _filter.Объект:
            obj_id = HistoryHelper.get_ID_For_Table( 'ИсторияОбъект', 'Объект', obj, 'object_', True, self.db )
            if obj_id:
               object_id_list.append( obj_id )
         if len( object_id_list ) &gt; 1:
            str_id_object = '{' + ','.join( str( id ) for id in object_id_list ) + '}'
            self.condition_where_object = """ ANY ( '{objects_id}'::bigint[] ) """.format( object_id = str_id_object )
         elif len( object_id_list ) == 1:
            self.condition_where_object = str( object_id_list[ 0 ] )
         else:
            raise Exception( 'Неизвестный объект истории ' )


   def TestFilter( self, field_name ):
      if self.filter.TestField( field_name ) is not None \
            and not self.filter[field_name].IsNull() \
            and str( self.filter[field_name] ).strip() != "":
         return True
      return False


   def RequiredFilters( self ):
      if self.TestFilter( 'СайтХост' ):
         _host = HistoryHelper.get_ID_For_Table( "ИсторияСайтХост", "Название", self.filter.СайтХост, 'site_host_', True, self.db )
         if _host:
            self.site_host = str( _host )
         else:
            return False
      else:
         raise Exception( """Отсутствует обязательный фильтр "СайтХост" """ )

      if self.TestFilter( 'СайтАдм' ):
         _adm = HistoryHelper.get_ID_For_Table( "ИсторияСайтАдм", "Название", self.filter.СайтАдм, 'site_adm_', True, self.db )
         if _adm:
            self.site_adm = str( _adm )
         else:
            return False
      else:
         raise Exception( """Отсутствует обязательный фильтр "СайтАдм" """ )

      if self.TestFilter( 'Клиент' ):
         self.client = str( self.filter.Клиент )
      else:
         raise Exception( """Отсутствует обязательный фильтр "Клиент" """ )

      return True



   def GetHistoryPart( self ):
      if self.RequiredFilters():
         # Тело выборки
         # .................................................................................................................................

         if self.from_method == 'History_Of_Instance':
            self.instance_id = sbis.SqlQueryScalar("""  SELECT  "@ИсторияЭкземплярОбъекта"

                                                        FROM    "ИсторияЭкземплярОбъекта"

                                                        WHERE   "Объект" = {obj} AND
                                                                "ИдО" = {ObjID} """.format( obj = self.condition_where_object, ObjID = str( self.filter.ИдО ) ) )

            if self.instance_id is None:
               return None

            mainQuery = """
                  SELECT          "Когда" AS "_time",
                                  "Когда" AS "_real_time",
                              "Сообщение" AS "_message",
                        T1."Пользователь" AS "_subject_id",
                        T1."IPВнутренний" AS "_ip_inner",
                               NULL::text AS "_subject_name"

                  FROM
                     "ИсторияСобытие" T0
                  INNER JOIN
                     "КонтекстИсполнения" T1
                              ON   T0."КонтекстИсполнения" = T1."@КонтекстИсполнения"
                  WHERE
                     T0."Клиент" = {client} AND
                     "СайтАдм" = {site_adm} AND
                     "СайтХост" = {site_host} AND
                     "ЭкземплярОбъекта" = {instance_id}
                  """.format(
                           client = self.client,
                           site_adm = self.site_adm,
                           site_host = self.site_host,
                           instance_id = self.instance_id )

         # .................................................................................................................................

         elif self.from_method == 'History_Of_Object_Last_Change':
            mainQuery = """
                  SELECT         T3."ИдО" AS "_object_id",
                            T3."Название" AS "_object_name",
                            T2."Действие" AS "_action",
                               T0."Когда" AS "_time",
                               T0."Когда" AS "_real_time",
                        T1."Пользователь" AS "_subject_id",
                        T1."IPВнутренний" AS "_ip_inner",
                               NULL::text AS "_subject_name",
                              T5."Объект" AS "_history_object"

                  FROM
                     "ИсторияСобытие" T0

                  INNER JOIN (
                                   SELECT      DISTINCT ON ( "ЭкземплярОбъекта" )
                                                "Когда" AS "Time",
                                     "ЭкземплярОбъекта" AS "Object"
                                   FROM
                                     "ИсторияСобытие"
                                   WHERE
                                     "ИдентификаторОбъекта" = {object_id}
                                   ORDER BY "Object", "Time" DESC

                             ) T4
                              ON   T0."Когда" = "Time" AND T0."ЭкземплярОбъекта" = "Object"
                  INNER JOIN
                     "КонтекстИсполнения" T1
                              ON   T0."КонтекстИсполнения" = T1."@КонтекстИсполнения"
                  INNER JOIN
                     "ИсторияДействие" T2
                              ON   T0."Действие" = T2."@ИсторияДействие"
                  INNER JOIN
                     "ИсторияЭкземплярОбъекта" T3
                              ON   T0."ЭкземплярОбъекта" = T3."@ИсторияЭкземплярОбъекта"
                  INNER JOIN
                     "ИсторияОбъект" T5
                              ON   T0."ИдентификаторОбъекта" = T5."@ИсторияОбъект"
                  WHERE
                     T0."Клиент" = {client} AND
                     "СайтАдм" = {site_adm} AND
                     "СайтХост" = {site_host}
                  """.format(
                           client = self.client,
                           site_adm = self.site_adm,
                           site_host = self.site_host,
                           object_id = self.condition_where_object )

         # .................................................................................................................................

         elif self.from_method == 'History_Of_Documents_Last_Change':

            mainQuery = """
                  SELECT         T3."ИдО" AS "_object_id",
                            T2."Действие" AS "_action",
                               T0."Когда" AS "_time"

                  FROM
                     "ИсторияСобытие" T0

                  INNER JOIN (
                                   SELECT      DISTINCT ON ( "ЭкземплярОбъекта" )
                                                "Когда" AS "Time",
                                     "ЭкземплярОбъекта" AS "Object"
                                   FROM
                                     "ИсторияСобытие"
                                   WHERE
                                     "ИдентификаторОбъекта" = {objects_id}
                                   ORDER BY "Object", "Time" DESC

                             ) T4
                              ON   T0."Когда" = "Time" AND T0."ЭкземплярОбъекта" = "Object"
                  INNER JOIN
                     "ИсторияДействие" T2
                              ON   T0."Действие" = T2."@ИсторияДействие"
                  INNER JOIN
                     "ИсторияЭкземплярОбъекта" T3
                              ON   T0."ЭкземплярОбъекта" = T3."@ИсторияЭкземплярОбъекта"
                  WHERE
                     T0."Клиент" = {client} AND
                     "СайтАдм" = {site_adm} AND
                     "СайтХост" = {site_host}
                  """.format(
                           client = self.client,
                           objects_id = self.condition_where_object,
                           site_adm = self.site_adm,
                           site_host = self.site_host
                           )

         # .................................................................................................................................

         elif self.from_method == 'History_Of_Object':
            mainQuery = """
                  SELECT       T0."Когда" AS "_time",
                               T0."Когда" AS "_real_time",
                              "Сообщение" AS "_message",
                        T1."Пользователь" AS "_subject_id",
                        T1."IPВнутренний" AS "_ip_inner",
                               NULL::text AS "_subject_name"

                  FROM
                     "ИсторияСобытие" T0
                  INNER JOIN
                     "КонтекстИсполнения" T1
                              ON   T0."КонтекстИсполнения" = T1."@КонтекстИсполнения"
                  INNER JOIN
                     "ИсторияЭкземплярОбъекта" T3
                              ON   T0."ЭкземплярОбъекта" = T3."@ИсторияЭкземплярОбъекта"
                  WHERE
                     T0."Клиент" = {client} AND
                     "СайтАдм" = {site_adm} AND
                     "СайтХост" = {site_host} AND
                     "ИдентификаторОбъекта" = {object_id}
                  """.format(
                            client = self.client,
                            site_adm = self.site_adm,
                            site_host = self.site_host,
                            object_id = str( self.object_id )
                           )

#            if self.TestFilter( 'Действие' ):
#               self.queryWhere =  self.queryWhere + """ AND T2."Действие" = '{0}' """.format( self.filter.Действие )

# ..........................................................................................................................................


         # Добавление фильтров
         if self.TestFilter( 'Сообщение' ):
            self.queryWhere = self.queryWhere + """ AND "Сообщение" ILIKE '%{0}%' """.format( self.filter.Сообщение )

         if self.TestFilter( 'Пользователь' ):
            self.queryWhere =  self.queryWhere + """ AND T1."Пользователь" = {0} """.format( self.filter.Пользователь )

         # сохраняем запрос для передачи его в History.List
         post_query = mainQuery + self.queryWhere


         if self.TestFilter( 'ВремяОт' ):
            self.queryWhere = self.queryWhere + """ AND "Когда" &gt;= '{time}' """.format( time = str( self.filter.ВремяОт ) )

         if self.TestFilter( 'ВремяДо' ):
            self.queryWhere = self.queryWhere + """ AND "Когда" &lt; '{time}' """.format( time = str( self.filter.ВремяДо ) )


         # Добавление параметров сортировки
# ..........................................................................................................................................
         query = mainQuery + self.queryWhere + """ ORDER BY "_time" DESC"""


         # Добавление лимита выборки
         if self.how_recs_return:
            query += """ LIMIT """ + str( self.how_recs_return )

         # Выполнение запроса
         self.res = sbis.SqlQuery( query )
         double_res = sbis.Record()
         double_res.AddRecordSet( 'result', self.res.Format(), self.res )
         double_res.AddString( 'query', post_query )
         double_res.AddInt32( 'id_db', self.db )

         return double_res

      else:
         return None
return HistoryConstructor( _filter, how_recs_return, id_db_in, from_method ).GetHistoryPart()</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="History.Get_List_Part_Additional" responsible="Желдокас С.А." returns="RECORD" type="PYTHON">
      <parameter name="query">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="result_additional">
        <format>
          <type>RECORDSET</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>query_result = SqlQuery( query )
result_additional = Record()
result_additional.AddRecordSet( 'result_additional', result_additional.Format() )
return result_additional</body>
      </definition>
    </select>
    <select access_mode="0" is_service="1" last_changed="Желдокас С.А." name="History.Get_Part_Name" responsible="Желдокас С.А." returns="TABLE" type="PYTHON">
      <parameter name="_db_id">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="_filter">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <parameter name="_how_name">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <return name="_time">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="_subject_id">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>from HistoryHelper import DBCarousel
from HistoryHelper import HistoryHelper
import sbis



DBCarousel.set_ID_Current_DB( _db_id )

_object_id = HistoryHelper.get_ID_For_Table( 'ИсторияОбъект', 'Объект', _filter.object, 'object_', True, _db_id )

if _object_id:
   _site_host = HistoryHelper.get_ID_For_Table( "ИсторияСайтХост", "Название", _filter.site_host, 'site_host_', True, _db_id )
   _site_adm = HistoryHelper.get_ID_For_Table( "ИсторияСайтАдм", "Название", _filter.site_adm, 'site_adm_', True, _db_id )
   _client = _filter.client

   if 'instance' in _filter:
      instance_id = HistoryHelper.get_Inst_Obj_ID( _filter.instance, _object_id, _client, True, _db_id )
      condition_where = """ "ЭкземплярОбъекта" = """ + str( instance_id )
   else:
      condition_where = """ "ИдентификаторОбъекта" = """ + str( _object_id )


   query = """    SELECT      DISTINCT ON ( "СубъектИд" )
                                       T1."Когда" AS "_time",
                                       T0."СубъектИд" AS "_subject_id"

                  FROM                 "КонтекстИсполнения" T0

                  JOIN        ( SELECT "КонтекстИсполнения",
                                       "Когда"

                                FROM   "ИсторияСобытие"

                                WHERE  {where} AND
                                       "Клиент" = {client} AND
                                       "СайтАдм" = '{site_adm}' AND
                                       "СайтХост" = '{site_host}' ) T1

                                  ON   T0."@КонтекстИсполнения" = T1."КонтекстИсполнения"

                  ORDER BY             "СубъектИд", "_time" DESC

                  LIMIT                {how} """.format(
                                          where = condition_where,
                                          how = str( _how_name ),
                                          client = str( _client ),
                                          site_adm = str(_site_adm),
                                          site_host = (_site_host) )
   sbis.ErrorMsg(_filter.object)
   sbis.ErrorMsg(query)
   result = sbis.SqlQuery( query )

   return result</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." module_api_part="1" name="History.HandleHistory" responsible="Буравлев М.С." returns="SCALAR" type="PYTHON">
      <parameter name="event">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>from HistoryHelper import HistoryHelper

LogMsg( 'Сайт ' + str( Session.Get(WebServerContextKey.icsHOST) ) )

HistoryHelper.WriteHistory(
   message = event.Сообщение,
   _object = event.Объект,
   _key = event.ИдО,
   action = event.Действие,
   client = event.Клиент,
   when = event.Когда,
   ctx_usr = event.Пользователь,
   ctx_subj = event.Субъект,
   ctx_ip = event.IP,
   ctx_inner_ip = event.IPВнутренний,
   site_host = event.СайтХост,
   site_adm = event.СайтАдм,
   object_attr = event.Атрибуты
)</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." module_api_part="1" name="History.Initialize_Objects" responsible="Желдокас С.А." returns="NONE" type="PYTHON">
      <parameter name="table_object_name">
        <format>
          <type>RECORDSET</type>
        </format>
      </parameter>
      <parameter name="client_id">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="history_object_name">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>from HistoryHelper import DBCarousel
from HistoryHelper import HistoryHelper


current_db = DBCarousel.getCurrentDBID( )

for id_db in range( 0, DBCarousel.db_ids_len ):

   DBCarousel.set_ID_Current_DB( id_db )

   history_object_id = HistoryHelper.get_ID_For_Table( 'ИсторияОбъект', 'Объект', history_object_name, 'object_', False, id_db )

   if history_object_id:

      for instance in table_object_name:

         inst_obj_id = HistoryHelper.get_Inst_Obj_ID( instance.object_id, history_object_id, client_id, False, id_db )

         if inst_obj_id:

            HistoryHelper.write_Instance_Name( instance.object_name, inst_obj_id, id_db )


DBCarousel.set_ID_Current_DB( current_db )</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." module_api_part="1" name="History.Last_Changed" responsible="Желдокас С.А." returns="ARRAY" type="PYTHON">
      <parameter name="_filter">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>INT4[]</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>import sbis
from HistoryHelper import DBCarousel

how_name = 5

def DictionaryLastChanged( change_set ):
   subject_dict = dict()

   for rec in change_set:
      if rec._subject_id in subject_dict:
         if subject_dict[ rec._subject_id ]._time &lt; rec._time:
            subject_dict[ rec._subject_id ] = rec
      else:
         subject_dict[ rec._subject_id ] = rec

   return subject_dict


frm = sbis.MethodResultFormat( 'History.Get_Part_Name', 3 )
result = sbis.CreateRecordSet( frm )
future_list = []

# Выполняем запрос ко всем базам данных
for id_db_in in range( 0, DBCarousel.db_ids_len ):
   future_object = sbis.BLObject( "History" ).FutureInvoke( "Get_Part_Name", id_db_in, _filter, how_name )
   future_list.append( future_object )

# Слияние результатов из баз
for future in future_list:
   listPart = future.get()
   if listPart:
      for rec in listPart:
         result.AddRow( rec )

last_changed = sbis.CreateRecordSet( result.Format() )

subject_dict = DictionaryLastChanged( result )


for subject_dict_item in subject_dict:
   last_changed.AddRow( subject_dict[ subject_dict_item ] )


last_changed.SortRows( lambda rec_a, rec_b: rec_a._time &gt; rec_b._time )

indexForDel = range( how_name, last_changed.Size() )
for i in reversed( indexForDel ):
   last_changed.DelRow( i )

subj_id_list = []
for rec in last_changed:
   subj_id_list.append( rec._subject_id )

return subj_id_list</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="History.Last_Time_Of_Change" responsible="Желдокас С.А." returns="SCALAR" type="PYTHON">
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return SqlQueryScalar( """ SELECT MAX( "Когда" ) AS "last_time"

                           FROM "ИсторияСобытие" """ )</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." module_api_part="1" name="History.List" responsible="Желдокас С.А." returns="RECORD" type="PYTHON">
      <parameter name="from_method">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="_filter">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <parameter name="recs_on_page">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="page_number">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <return name="result">
        <format>
          <type>RECORDSET</type>
        </format>
      </return>
      <return name="is_next">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>import sbis
from HistoryHelper import DBCarousel

##########################################################################################################################################

def Navigation_Is_Next( record_set ):
   if recs_on_page and ( record_set.Size() - recs_on_page ) &gt; 0 :
      return True
   else:
      return False


def TestFilter( filter, field_name ):
   if filter.TestField( field_name ) is not None \
         and not filter[field_name].IsNull() \
         and str( filter[field_name] ).strip() != "":
      return True
   return False


def Merge_Async_Result( future_l, result_table ):
   # Слияние результатов из баз
   for future in future_l:
      outGetListPart = future.get()
      if outGetListPart:
         listPart = outGetListPart.result
         for rec in listPart:
            result_table.AddRow( rec )


def Dictionary_Of_Object_Last_Change( change_set ):
   instance_dict = dict()

   for rec in change_set:
      if rec._object_id in instance_dict:
         if instance_dict[ rec._object_id ]._time &lt; rec._time:
            instance_dict[ rec._object_id ] = rec
      else:
         instance_dict[ rec._object_id ] = rec

   return instance_dict


def Get_List_Part( how_recs ):
   frm = sbis.MethodResultFormat( 'История.'+ from_method, 4 )
   result = sbis.CreateRecordSet( frm )
   future_list = []

   # Выполняем запрос ко всем базам данных
   for id_db_in in range( 0, DBCarousel.db_ids_len ):
      #list_part = History.Get_List_Part( _filter, how_recs, id_db_in, from_method )
      future_object = sbis.BLObject( "History" ).FutureInvoke( "Get_List_Part", _filter, how_recs, id_db_in, from_method )
      future_list.append( future_object )

   # Слияние результатов из баз
   for future in future_list:
      outGetListPart = future.get()
      if outGetListPart:
         #query_after_query[ outGetListPart.id_db ] = outGetListPart.query
         listPart = outGetListPart.result
         for rec in listPart:
            result.AddRow( rec )
   return result

############################################################################################################################################
############################################################################################################################################


if from_method == 'History_Of_Object_Last_Change':

   if recs_on_page != None and page_number != None:
      how_recs_return = ( recs_on_page * ( page_number + 1 ) )
   else:
      how_recs_return = None

   resultRS = Get_List_Part( how_recs_return )

   result_last_change = sbis.CreateRecordSet( resultRS.Format() )

   instance_dict = Dictionary_Of_Object_Last_Change( resultRS )

   if TestFilter( _filter, 'Действие' ):

      if TestFilter( _filter, 'ВремяОтсчета'):
         for instance_dict_item in instance_dict:
            if instance_dict[ instance_dict_item ]._time &lt; _filter.ВремяОтсчета and instance_dict[ instance_dict_item ]._action == _filter.Действие:
               result_last_change.AddRow( instance_dict[ instance_dict_item ] )
      else:
         for instance_dict_item in instance_dict:
            if instance_dict[ instance_dict_item ]._action == _filter.Действие:
               result_last_change.AddRow( instance_dict[ instance_dict_item ] )

   else:

      if TestFilter( _filter, 'ВремяОтсчета'):
         for instance_dict_item in instance_dict:
            if instance_dict[ instance_dict_item ]._time &lt; _filter.ВремяОтсчета:
               result_last_change.AddRow( instance_dict[ instance_dict_item ] )
      else:
         for instance_dict_item in instance_dict:
            result_last_change.AddRow( instance_dict[ instance_dict_item ] )

   result_last_change.SortRows( lambda rec_a, rec_b: rec_a._real_time &gt; rec_b._real_time )

   if Navigation_Is_Next( result_last_change ):
      is_next = True
      indexForDel = range( recs_on_page, result_last_change.Size() )
      for i in reversed( indexForDel ):
         result_last_change.DelRow( i )
   else:
      is_next = False

   result = result_last_change

elif from_method == 'History_Of_Instance':

   if TestFilter( _filter, 'ВремяОтсчета' ):
      _filter.ВремяДо = _filter.ВремяОтсчета

   result = Get_List_Part( recs_on_page )

   # Сортировка
   result.SortRows( lambda rec_a, rec_b: rec_a._real_time &gt; rec_b._real_time )

   # Передаем ответ навигации
   if Navigation_Is_Next( result ):
      is_next = True

      # Удаляем лишние строки выборки до запрашиваемой длины
      indexForDel = range( recs_on_page, result.Size() )
      for i in reversed( indexForDel ):
         result.DelRow( i )

   else:
      is_next = False

   # расчитываем и добавляем пустые поля
   for rec in result:
      rec._time = rec._real_time.replace( second = 0, microsecond = 0 )

elif from_method == 'History_Of_Object':

   if TestFilter( _filter, 'ВремяОтсчета' ):
      _filter.ВремяДо = _filter.ВремяОтсчета

   result = Get_List_Part( recs_on_page )

   # Сортировка
   result.SortRows( lambda rec_a, rec_b: rec_a._real_time &gt; rec_b._real_time )

   # Передаем ответ навигации
   if Navigation_Is_Next( result ):
      is_next = True

      # Удаляем лишние строки выборки до запрашиваемой длины
      indexForDel = range( recs_on_page, result.Size() )
      for i in reversed( indexForDel ):
         result.DelRow( i )

   else:
      is_next = False

   # расчитываем и добавляем пустые поля
   for rec in result:
      rec._time = rec._real_time.replace( second = 0, microsecond = 0 )


result_rec = sbis.Record()
result_rec.AddRecordSet( 'result', result.Format() )
result_rec.result = result
result_rec.AddBool( 'is_next', is_next )

return result_rec</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="History.List_For_Documents" responsible="Желдокас С.А." returns="TABLE" type="PYTHON">
      <parameter name="_filter">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="_object_id">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="_action">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="_time">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>import datetime
import sbis
from HistoryHelper import DBCarousel
from HistoryHelper import HistoryHelper

future_list = []
frm = sbis.MethodResultFormat( 'История.History_Of_Documents_Last_Change', 4 )
resultRS = sbis.CreateRecordSet( frm )
##########################################################################################################################################

def TestFilter( filter, field_name ):
   if filter.TestField( field_name ) is not None \
         and not filter[field_name].IsNull() \
         and str( filter[field_name] ).strip() != "":
      return True
   return False

##########################################################################################################################################

def Dictionary_Of_Object_Last_Change( change_set ):
   instance_dict = dict()

   for rec in change_set:
      if rec._object_id in instance_dict:
         if instance_dict[ rec._object_id ]._time &lt; rec._time:
            instance_dict[ rec._object_id ] = rec
      else:
         instance_dict[ rec._object_id ] = rec

   return instance_dict

##########################################################################################################################################

delta_2_min = datetime.timedelta( minutes = 2 )
future_object_list = []
time_list = []

for id_db_in in range( 0, DBCarousel.db_ids_len ):
   future_object = sbis.BLObject( "History" ).FutureInvoke( "Last_Time_Of_Change" )
   future_object_list.append( future_object )

for fu_obj in future_object_list:
   time_list.append( fu_obj.get() )

time_list.sort()
last_time_from_base = time_list[ 0 ]
time_compare = last_time_from_base - delta_2_min

if time_compare &lt; _filter.ВремяДо:
   _filter.ВремяДо = time_compare

# ..........................................................................................................................................


# Выполняем запрос ко всем базам данных
for id_db_in in range( 0, DBCarousel.db_ids_len ):
   future_object = sbis.BLObject( "History" ).FutureInvoke( "Get_List_Part", _filter, None, id_db_in, 'History_Of_Documents_Last_Change' )
   future_list.append( future_object )

# Слияние результатов из баз
for future in future_list:
   outGetListPart = future.get()
   if outGetListPart:
      listPart = outGetListPart.result
      for rec in listPart:
         resultRS.AddRow( rec )

# ..........................................................................................................................................

result_last_change = sbis.CreateRecordSet( resultRS.Format() )

instance_dict = dict()

for rec in resultRS:
   if rec._object_id in instance_dict:
      if instance_dict[ rec._object_id ]._time &lt; rec._time:
         instance_dict[ rec._object_id ] = rec
   else:
      instance_dict[ rec._object_id ] = rec

if TestFilter( _filter, 'Действие' ):
   for instance_dict_item in instance_dict:
      if instance_dict[ instance_dict_item ]._action in _filter.Действие:
         result_last_change.AddRow( instance_dict[ instance_dict_item ] )
else:
   for instance_dict_item in instance_dict:
      result_last_change.AddRow( instance_dict[ instance_dict_item ] )

return result_last_change</body>
      </definition>
    </select>
  </object>

</repository>
