<?xml version="1.0" encoding="WINDOWS-1251" ?>
<repository orx_version="1.74">

  <object name="Авторизация">
    <select access_mode="0" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.AddParentRole" responsible="Шаброва А.Н." returns="SCALAR" type="PYTHON">
      <parameter name="client_id">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="role">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="parent_role">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>SqlQuery( """
delete from "ЗависимостиРолей" t where t."ДочерняяРоль" = '""" + role + """' AND t."БазоваяРоль" = '""" + parent_role + """' AND "Пользователь" = """ + str(client_id) + """;
insert into "ЗависимостиРолей" ( "БазоваяРоль", "ДочерняяРоль", "Пользователь" ) values( '""" + parent_role + """', '""" + role + """', """ + str(client_id) + """);""" )
return True</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.AnotherUserRoles" responsible="Шаброва А.Н." returns="TABLE" type="PYTHON">
      <parameter name="ИдПользователя">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="ПраваВПерсональнойСхеме">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <return name="@Пользователь">
        <format>
          <type>INT64</type>
        </format>
      </return>
      <return name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="КлассПользователя">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>classes = str( Пользователь.СписокКлассов() )
userID = str( ИдПользователя )
scheme_str = '' if ПраваВПерсональнойСхеме else 'public.'
query = """
WITH RECURSIVE T AS (
  (
      SELECT
              "@Пользователь", "Раздел", "НаследоватьПрава", "Логин"
      FROM
              "Пользователь"
      WHERE
              "@Пользователь" = """ + userID + """ 
      UNION ALL
      SELECT
             NULL, NULL, NULL, NULL
      LIMIT 1
  )
UNION ALL
      SELECT
              us."@Пользователь", us."Раздел", us."НаследоватьПрава",	us."Логин"
      FROM
              T
      JOIN
              "Пользователь" us
                     ON us."@Пользователь" = T."Раздел"
      WHERE
		coalesce(T."Логин", '') NOT IN (""" + classes + """) 
)
SELECT
	T."@Пользователь", r."Название" "Роль", T."Логин" IN ( """ + classes + """ ) IS TRUE "КлассПользователя"
FROM
	T
LEFT JOIN
	""" + scheme_str + """"РолиПользователей" r
		ON r."Пользователь" = T."@Пользователь"  
WHERE
	"НаследоватьПрава" IS NOT TRUE;
"""
format = MethodResultFormat( "Авторизация.AnotherUserRoles", 2)
return SqlQuery( query , format )</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.CurrentUserRoles" responsible="Шаброва А.Н." returns="TABLE" type="PYTHON">
      <cached forwhom="user" lifetime="2880"/>
      <parameter name="ПраваВПерсональнойСхеме">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <return name="@Пользователь">
        <format>
          <type>INT64</type>
        </format>
      </return>
      <return name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="КлассПользователя">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>userID = Session.UserID()
res = 0
if str( userID ) == '' or userID is None :
   raise TypeError ( 'Не удалось определить текущего клиента. Идентификатор sbis3.userID не заполнен.' )
try:
   res = int( userID )
except ValueError:
   raise ValueError ( 'Не удалось определить текущего клиента. Идентификатор sbis3.userID должен быть целым числом, а имеет значение - "%s".' % userID )
return Авторизация.AnotherUserRoles( res, ПраваВПерсональнойСхеме )</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.SetForServiceUsers" responsible="Кондратьев М.А." returns="NONE" type="PYTHON">
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ForServiceUsers">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>for_service_users = 'true' if ForServiceUsers else 'false'
res = SqlQueryScalar( ( """select exists( SELECT "Роль" FROM "ПараметрыРоли" WHERE "Роль" = '""" + Роль + """' AND "Пользователь" = {clientId} )""" ).format( clientId = ИдКлиента ) )
if res:
   SqlQuery( ( """UPDATE "ПараметрыРоли" SET "ForServiceUsers" = """ + for_service_users + """ WHERE "Роль" = '""" + Роль + """' AND "Пользователь" = {clientId};""" ).format( clientId = ИдКлиента ) )
else:
   SqlQuery( ( """INSERT INTO "ПараметрыРоли"( "Роль", "ForServiceUsers", "Пользователь" ) VALUES( '""" + Роль + """', """ + for_service_users + """, {clientId} );""" ).format( clientId = ИдКлиента ) )</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.SetHierRole" responsible="Шаброва А.Н." returns="SCALAR" type="PYTHON">
      <parameter name="client_id">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="role">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="parent_role">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>res = SqlQueryScalar( ( """select exists( SELECT "Роль" FROM "ПараметрыРоли" WHERE "Роль" = '""" + role + """' AND "Пользователь" = {clientId} )""" ).format( clientId = client_id ) )
if res:
   SqlQuery( ( """UPDATE "ПараметрыРоли" SET "Раздел" = '""" + parent_role + """' WHERE "Роль" = '""" + role + """' AND "Пользователь" = {clientId};""" ).format( clientId = client_id ) )
else:
   SqlQuery( ( """INSERT INTO "ПараметрыРоли"( "Роль", "Раздел", "Пользователь" ) VALUES( '""" + role + """', '""" + parent_role + """', {clientId} );""" ).format( clientId = client_id ) )
return True</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Зона доступа" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.UpdateAccess" responsible="Шаброва А.Н." returns="SCALAR" type="PYTHON">
      <parameter name="Role">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="AccessArea">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Access">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="clientID">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>SqlQuery( """
DELETE FROM "НастройкиЗоныДоступа" WHERE "AccessArea" = '""" + AccessArea + """' AND "Пользователь" = """ + str( clientID ) + """ AND "Роль" = '""" + Role + """' AND "Access" IS NOT NULL;
INSERT INTO "НастройкиЗоныДоступа" ("AccessArea", "Роль", "Access", "Пользователь" ) 
   VALUES ( '""" + AccessArea + """','""" + Role + """', '""" + Access + """', """ + str( clientID ) + """ );""" )
   
КэшированиеМетодов.ОчиститьКэшКлиента( clientID, 'Авторизация.НастройкиЗонДоступа', 1)
return True</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Зона доступа" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.UpdateAosSettings" responsible="Шаброва А.Н." returns="SCALAR" type="PYTHON">
      <parameter name="Role">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="AccessArea">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="AosFunction">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ScopeFlags">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="AosSettings">
        <format>
          <type>INT8[]</type>
        </format>
      </parameter>
      <parameter name="clientID">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>aos_settings = 'NULL'
if AosSettings is not None :
   aos_settings = 'ARRAY' + str( AosSettings )
SqlQuery( """
DELETE FROM "НастройкиЗоныДоступа" WHERE "AccessArea" = '""" + AccessArea + """' AND "Пользователь" = """ + str( clientID ) + """ AND "Роль" = '""" + Role + """' AND "AosFunction" = '""" + AosFunction + """';
INSERT INTO "НастройкиЗоныДоступа" ( "AccessArea", "Роль", "AosFunction", "ScopeFlags", "Settings", "Пользователь" ) 
   VALUES ( '""" + AccessArea + """','""" + Role + """', '""" + AosFunction + """', '""" + ScopeFlags + """', (""" + aos_settings + """)::integer[],  """ + str( clientID ) + """ );""" )
   
КэшированиеМетодов.ОчиститьКэшКлиента( clientID, 'Авторизация.НастройкиЗонДоступа', 1)
return True</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.UserRoles" responsible="Шаброва А.Н." returns="TABLE" type="PYTHON">
      <parameter name="userId">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="personal">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <return name="@Пользователь">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>Пользователь</table>
          <column>@Пользователь</column>
        </format>
      </return>
      <return name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="КлассПользователя">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>classes = str( Пользователь.СписокКлассов() )
userID = str( userId )
scheme_str = '' if personal else 'public.'

query = """
WITH RECURSIVE T AS (
  (
      SELECT
              "@Пользователь", "Раздел", "НаследоватьПрава", "Логин"
      FROM
              "Пользователь"
      WHERE
              "@Пользователь" = """ + userID + """ 
      UNION ALL
      SELECT
             NULL, NULL, NULL, NULL
      LIMIT 1
  )
UNION ALL
      SELECT
              us."@Пользователь", us."Раздел", us."НаследоватьПрава",	us."Логин"
      FROM
              T
      JOIN
              "Пользователь" us
                     ON us."@Пользователь" = T."Раздел"
      WHERE
		coalesce(T."Логин", '') NOT IN (""" + classes + """) 
)
SELECT
	T."@Пользователь", r."Название" "Роль", T."Логин" IN ( """ + classes + """ ) IS TRUE "КлассПользователя"
FROM
	T
LEFT JOIN
	""" + scheme_str + """"РолиПользователей" r
		ON r."Пользователь" = T."@Пользователь"  
WHERE
	"НаследоватьПрава" IS NOT TRUE;
"""

format = MethodResultFormat( "Авторизация.РолиПользователя", 2)
return SqlQuery( query , format )</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.UserRolesOwn" responsible="Шаброва А.Н." returns="TABLE" type="PYTHON">
      <cached forwhom="user" lifetime="2880"/>
      <parameter name="personal">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <return name="@Пользователь">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>Пользователь</table>
          <column>@Пользователь</column>
        </format>
      </return>
      <return name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="КлассПользователя">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return Авторизация.UserRoles( Session.UserID(), personal )</body>
      </definition>
    </select>
    <select access_mode="1" category="Служебные функции" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.UserSettings" responsible="Шаброва А.Н." returns="TABLE" type="SQL">
      <parameter name="User">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="AccessArea">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="AosFunction">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Access">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="ScopeFlags">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="AosSettings">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>Settings</column>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>select 
   "AccessArea", 
   "AosFunction", 
   "Access",
   "ScopeFlags",
   "Settings" as "AosSettings"
from 
   "НастройкиЗоныДоступа" 
where 
   "Пользователь" = :User
   and 
   "Роль" is null;</body>
      </definition>
    </select>
    <select access_mode="1" category="Предотвращение самоблокировки" is_proxy="0" is_service="0" last_changed="Буравлев М.С." module_api_part="1" name="Авторизация.АдминистраторыКлиента" responsible="Буравлев М.С." returns="ARRAY" type="NATIVE">
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>INT4[]</type>
        </format>
      </return>
    </select>
    <select access_mode="0" category="Служебные функции" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.ДобавитьПользователейКРоли" responsible="Кондратьев М.А." returns="NONE" type="PYTHON">
      <transaction type="required"/>
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Пользователи">
        <format>
          <type>INT4[]</type>
        </format>
      </parameter>
      <parameter name="ПраваВПерсональнойСхеме">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: str( res ) if res is not None else 'null'
role = fun( Роль )
users = fun(Пользователи)[1:-1]
users = "'{" + users + "}'"
scheme_str = '' if ПраваВПерсональнойСхеме else 'public.'

SqlQuery( """
DELETE FROM """ + scheme_str + """"РолиПользователей" WHERE "Название" = '""" + role + """' AND "Пользователь" = ANY( """ + users + """::integer[] );
INSERT INTO """ + scheme_str + """"РолиПользователей" ( "Пользователь", "Название" ) SELECT unnest( """ + users + """::integer[] ), '""" + role + """';""" )

for user in Пользователи:
   КэшированиеМетодов.ОчиститьКэшПользователя( user, 'Авторизация.UserRolesOwn', 1 )</body>
      </definition>
    </select>
    <select access_mode="1" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.ЗависимостиРолей" responsible="Шаброва А.Н." returns="TABLE" type="SQL">
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="БазоваяРоль">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>ЗависимостиРолей</table>
          <column>БазоваяРоль</column>
        </format>
      </return>
      <return name="ДочерняяРоль">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>ЗависимостиРолей</table>
          <column>ДочерняяРоль</column>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>SELECT 
   u."БазоваяРоль",
   u."ДочерняяРоль"
FROM
   "ЗависимостиРолей" u 
WHERE
   "Пользователь" = :ИдКлиента;</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.ЗаписатьКлиентскуюРоль" responsible="Шаброва А.Н." returns="SCALAR" type="PYTHON">
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Примечание">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: str( res ) if res is not None else 'null'
arole = fun( Роль )
name = fun( Название )
comment = fun( Примечание )
res = SqlQueryScalar( ( """SELECT exists( SELECT "Имя" FROM "КлиентскаяРоль" WHERE "Имя" = ('""" + arole + """')::text AND "Пользователь" = {clientId} )""" ).format( clientId = ИдКлиента ) )
if res:
   SqlQuery( ( """ UPDATE "КлиентскаяРоль" SET "Название" = ('""" + name + """')::text, "Примечание" = ('""" + comment + """')::text WHERE "Имя" = ('""" + arole + """')::text AND "Пользователь" = {clientId};""" ).format( clientId = ИдКлиента ) )
else:
   SqlQuery( ( """ INSERT INTO "КлиентскаяРоль" ( "Имя", "Название", "Примечание", "Пользователь" ) VALUES ( ('""" + arole + """')::text, ('""" + name + """')::text, ('""" + comment + """')::text, {client} );""" ).format( client = ИдКлиента ) )
return arole</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.ЗаписатьПараметрСкрытая" responsible="Кондратьев М.А." returns="NONE" type="PYTHON">
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Скрытая">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: str( res ) if res is not None else 'null'
role = fun( Роль )
hidden = fun( Скрытая )
res = SqlQueryScalar( ( """select exists( SELECT "Роль" FROM "ПараметрыРоли" WHERE "Роль" = '""" + role + """' AND "Пользователь" = {clientId} )""" ).format( clientId = ИдКлиента ) )
if res:
   SqlQuery( ( """UPDATE "ПараметрыРоли" SET "Скрытая" = """ + hidden + """ WHERE "Роль" = '""" + role + """' AND "Пользователь" = {clientId};""" ).format( clientId = ИдКлиента ) )
else:
   SqlQuery( ( """INSERT INTO "ПараметрыРоли"( "Роль", "Скрытая", "Пользователь" ) VALUES( '""" + role + """',""" + hidden + """, {clientId} );""" ).format( clientId = ИдКлиента ) )</body>
      </definition>
    </select>
    <select access_mode="1" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.КлиентскиеРоли" responsible="Шаброва А.Н." returns="TABLE" type="SQL">
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="Имя">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>КлиентскаяРоль</table>
          <column>Имя</column>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>КлиентскаяРоль</table>
          <column>Название</column>
        </format>
      </return>
      <return name="Примечание">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>КлиентскаяРоль</table>
          <column>Примечание</column>
        </format>
      </return>
      <return name="Overridden">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>SELECT
   r."Имя", r."Название", r."Примечание", r."Overridden"
FROM 
   "КлиентскаяРоль" r
WHERE 
   r."Пользователь" = :ИдКлиента;</body>
      </definition>
    </select>
    <standart_select access_mode="1" is_proxy="0" is_service="0" last_changed="Щукин А.В." module_api_part="1" name="Авторизация.МаксимальныеРолиПользователя" responsible="Шаброва А.Н." type="NATIVE">
      <comment>Возвращает иерархический список максимальных прав пользователя. К каждой роли присутствует отметка, назначена ли она пользователю</comment>
      <return name="@Роль">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Примечание">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Скрытая">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Системная">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="ForServiceUsers">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Порядок">
        <format>
          <type>DOUBLE</type>
        </format>
      </return>
      <return name="Идентификатор">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Назначена">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="ДоступнаЛиДляНазначения">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <std_parameter filter_category="USER" name="Пользователь" param_type="REQUIRED" type="INT64"/>
      <std_parameter filter_category="USER" name="АдресСервиса" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="ForServiceUsers" param_type="OPTIONAL" type="TEXT"/>
    </standart_select>
    <standart_select access_mode="1" is_service="0" last_changed="Щукин А.В." module_api_part="1" name="Авторизация.МаксимальныеРолиПользователяСГруппами" responsible="Кондратьев М.А." type="PYTHON">
      <comment>Возвращает иерархический список максимальных прав пользователя. К каждой роли присутствует отметка, назначена ли она пользователю</comment>
      <return name="@Роль">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Примечание">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Скрытая">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Системная">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="ForServiceUsers">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Порядок">
        <format>
          <type>DOUBLE</type>
        </format>
      </return>
      <return name="Идентификатор">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Назначена">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="ДоступнаЛиДляНазначения">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>HIERARCHY</type>
          <nodes_field>1</nodes_field>
          <hierarchy_name>Название</hierarchy_name>
        </format>
      </return>
      <return name="Дир">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>def AddFolderOnlyWithName(rec,name,res):
      rec['@Роль'].From( '-1,-1' )
      rec['Название'].From( str( name ) )
      
      res.InsRow( res.Size(), rec )
      
#СписокИерархия для вкладки "права" в карточке пользователя

import re
rs = Авторизация.МаксимальныеРолиПользователя( ДопПоля, Фильтр, Сортировка, Навигация )

if "ТолькоНазначенные" in Фильтр and Фильтр.ТолькоНазначенные is True:
   rs_tmp = CreateRecordSet( rs.Format() )
   for r in rs:
      if r.Назначена:
         rs_tmp.InsRow( len(rs_tmp), r )
   rs = rs_tmp

#rs sorting
newrs = []
for item in range( len( rs ) ):
   newrs.insert( item , rs[ item ] )

indexUserRoleDir = 0
for item in range( len( newrs ) ):
   if str( newrs[ item ]['Название'] ).find('/') &gt; 0:
      rstmp = newrs[ item ]
      newrs.pop( item )
      newrs.insert( indexUserRoleDir, rstmp )
      indexUserRoleDir += 1
rs = newrs
#--------------
cache = []
HierarchyRec = Hierarchy()
recBlank = Record()
recBlank.AppendField( '@Роль', FieldType.ftIDENTIFIER, 0 )
recBlank.AppendField( 'Название', FieldType.ftTEXT, 0 )
recBlank.AddHierarchy( 'Раздел', HierarchyRec )
recBlank.AppendField( 'Примечание', FieldType.ftTEXT, 0 )
recBlank.AddBool( 'Скрытая', False )
recBlank.AddBool( 'Системная', False )
recBlank.AddBool( 'ForServiceUsers', False )
recBlank.AddBool( 'Назначена', False )
recBlank.AppendField( 'Порядок', FieldType.ftDOUBLE, 0 )
recBlank.AppendField( 'Идентификатор', FieldType.ftTEXT, 0 )
recBlank.AddInt32( 'Дир', 0 )
recBlank.AddBool( 'ДоступнаЛиДляНазначения', True )
res = RecordSet( recBlank.Format() )
i = 1                                                    # счетчик для уникальности ИД узла (папки) с ролями
systemRoleFolderCreated = 0
for item in range( len( rs ) ):
   roleID = 0                                            # нужен для записи последнего ИД узла в ветки
   roleLastName = ''                                     # имя последней или корневой директории
   dirPath = ''                                          # нужен для пошагового накопления пути директории
   dirLevel = 0
   exp = str( rs[ item ]['Название'] ).split( '/' , 1 )      # разделение строки и выделение папок дир1/дир2/дир3/лист
   # цикл - парсер директорий
   for e in range( 0, len( exp ) -1):                    # проходим по списку выделенных директорий дир1 , дир2 , дир3 - если он не пустой (-1 не берем лист)
      strExpE = str( exp[ e ] )                          # название директории из списка
      dirPath += strExpE + '/'                           # накапливаем путь от корня до текущей директории


      id = 0                                             # ИД директории и флаг - заполняется, если найден в кэше директорий

      for cacheItem in cache:                            # поиск в кеше по пути к текущей директории
         if cacheItem ['dirPath'] == dirPath:            # нашлось!!! тогда заполняем данные id, parID и parName
            id = cacheItem ['id']
            break
      if id:                                             # поиск в кеше был удачным и новая запись о директории в выходной рекордсет не добавляется
         roleID = id                                     # запоминается ИД для дальнейшей итерации поиска директории или для конечного узла роли
         roleLastName = strExpE                          # название текущей директории - такоеже как и в кеше.
         dirLevel += 1
      else:                                              # ничего не нашлось в кеше - создаём новую запись о директории в выходной рекордсет
         cache.append( {'id': i, 'dirPath': dirPath ,'parID': roleID, 'parName': roleLastName} ) # добавляем в кеш инфо о новой директории
         HierarchyRec = Hierarchy()
         HierarchyRec.Parent = ObjectId()
         HierarchyRec.Branch = BranchType.LEAF           # LEAF , NODE , HIDDEN - в данном случае директория это узел ( папка )
         HierarchyRec.HasChild = True                    # у директории есть дети

         rec = Record()
         rec.AppendField( '@Роль', FieldType.ftIDENTIFIER, 0 )
         #rec['@Роль'].From( str( i ) + ',' + strExpE ) # заполняем уникальный ИД роли и её название - это сложный ИД!
         rec['@Роль'].From( str( i ) + ',' + '-1' ) # заполняем уникальный ИД роли и её название - это сложный ИД!
         rec.AppendField( 'Название', FieldType.ftTEXT, 0 )
         rec['Название'].From( strExpE )                 # название текущей директории
         rec.AddHierarchy( 'Раздел', HierarchyRec )
         rec.AppendField( 'Примечание', FieldType.ftTEXT, 0 )
         rec.AddBool( 'Скрытая', False )
         rec.AddBool( 'Системная', False )
         rec.AddBool( 'ForServiceUsers', False )
         rec.AddBool( 'Назначена', False )
         rec.AppendField( 'Порядок', FieldType.ftDOUBLE, 0 )
         rec.AppendField( 'Идентификатор', FieldType.ftTEXT, 0 )
         rec.AddInt32( 'Дир', int( dirLevel ) )
         rec.AddBool( 'ДоступнаЛиДляНазначения', True )

         dirLevel += 1
         res.InsRow( res.Size(), rec )                          # добавление следующей строки в рекордсет

         roleID = i                                      # текущее значение ИД
         roleLastName = strExpE                          # текущее название директории
         i += 1

   #заполнение данных о листе
   HierarchyRec = Hierarchy()
   rec = Record()
   rec.AppendField( '@Роль', FieldType.ftIDENTIFIER, 0 )
   rec['@Роль'].From( re.sub( '(\d+,)', '0,', str( rs[ item ]['@Роль'] ) ) )
   rec.AppendField( 'Название', FieldType.ftTEXT, 0 )
   rec['Название'].From( str( exp[ -1 ] ) )              # название текущей директории
   rec.AddHierarchy( 'Раздел', HierarchyRec )

   if roleID == 0:
      if systemRoleFolderCreated == 0 and indexUserRoleDir != 0:
         AddFolderOnlyWithName(recBlank,'Прочие роли',res)
         systemRoleFolderCreated = 1

      dirLevel +=1

   rec.AppendField( 'Примечание', FieldType.ftTEXT, 0 )
   rec['Примечание'].From( str( rs[ item ]['Примечание'] ) )
   rec.AddBool( 'Скрытая')
   rec['Скрытая'].From( rs[ item ]['Скрытая'] )
   rec.AddBool( 'Системная')
   rec['Системная'].From( rs[ item ]['Системная'] )
   rec.AddBool( 'ForServiceUsers')
   rec['ForServiceUsers'].From( rs[ item ]['ForServiceUsers'] )
   rec.AddBool( 'Назначена')
   rec['Назначена'].From( rs[ item ]['Назначена'] )
   rec.AppendField( 'Порядок', FieldType.ftDOUBLE, 0 )
   rec['Порядок'].From( float( rs[ item ]['Порядок'] ) )
   rec.AppendField( 'Идентификатор', FieldType.ftTEXT, 0 )
   rec['Идентификатор'].From( str( rs[ item ]['Идентификатор'] ) )
   rec.AddInt32( 'Дир', int( dirLevel ) )
   rec.AddBool( 'ДоступнаЛиДляНазначения', False )
   rec['ДоступнаЛиДляНазначения'].From( rs[ item ]['ДоступнаЛиДляНазначения'] )
   
   res.InsRow( res.Size(), rec )                          # добавление следующей строки в рекордсет
#----------------------------------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------------------------------
mlr= MethodListResult()
mlr.cursor = res.Cursor()
mlr.nav_result = NavigationResult( res.Size() )
return mlr                                            # вернули рекордсет с иерархией</body>
      </definition>
      <std_parameter filter_category="USER" name="ТолькоНазначенные" param_type="OPTIONAL" type="BOOLEAN"/>
      <std_parameter filter_category="USER" name="Пользователь" param_type="REQUIRED" type="INT64"/>
      <std_parameter filter_category="USER" name="АдресСервиса" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="ForServiceUsers" param_type="OPTIONAL" type="BOOLEAN"/>
    </standart_select>
    <select access_mode="1" category="Служебные функции Зона доступа" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.НастройкиЗонДоступа" responsible="Buravlevms" returns="TABLE" type="SQL">
      <cached forwhom="client" lifetime="2880"/>
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="Роль">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>Роль</column>
        </format>
      </return>
      <return name="AccessArea">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>AccessArea</column>
        </format>
      </return>
      <return name="Access">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>Access</column>
        </format>
      </return>
      <return name="AosFunction">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>AosFunction</column>
        </format>
      </return>
      <return name="ScopeFlags">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>ScopeFlags</column>
        </format>
      </return>
      <return name="AosSettings">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>Settings</column>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>SELECT 
   u."Роль", u."AccessArea", u."Access", u."AosFunction", u."ScopeFlags", u."Settings" as "AosSettings"
FROM
   "НастройкиЗоныДоступа" u
WHERE
   u."Пользователь" = :ИдКлиента;</body>
      </definition>
    </select>
    <select access_mode="1" category="Служебные функции Зона доступа" is_service="1" name="Авторизация.НастройкиЗонДоступа" returns="TABLE" type="SQL">
      <parameter name="НаследникиРоли">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <parameter name="УказаннаяРоль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="Имя">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>Имя</column>
        </format>
      </return>
      <return name="Роль">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>Роль</column>
        </format>
      </return>
      <return name="Доступ">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>Доступ</column>
        </format>
      </return>
      <return name="ОбластиВидимости">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>НастройкиЗоныДоступа</table>
          <column>ОбластиВидимости</column>
        </format>
      </return>
      <return name="ДляУказаннойРоли">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>SELECT u."Имя", u."Роль", u."Доступ", u."ОбластиВидимости", u."Роль" IS NOT DISTINCT FROM :УказаннаяРоль as "ДляДаннойРоли"
      FROM "НастройкиЗоныДоступа" u
         WHERE u."Роль" = ANY( :НаследникиРоли ) OR u."Роль" IS NOT DISTINCT FROM :УказаннаяРоль;</body>
      </definition>
    </select>
    <select access_mode="1" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.ПараметрыРолей" responsible="Шаброва А.Н." returns="TABLE" type="SQL">
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="Роль">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>ПараметрыРоли</table>
          <column>Роль</column>
        </format>
      </return>
      <return name="Порядок">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>ПараметрыРоли</table>
          <column>Порядок</column>
        </format>
      </return>
      <return name="Скрытая">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>ПараметрыРоли</table>
          <column>Скрытая</column>
        </format>
      </return>
      <return name="ForServiceUsers">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>ПараметрыРоли</table>
          <column>ForServiceUsers</column>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>FIELDFROMTABLE</type>
          <table>ПараметрыРоли</table>
          <column>Раздел</column>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>SELECT 
   "Роль", "Порядок", "Скрытая", "ForServiceUsers", "Раздел"
FROM 
   "ПараметрыРоли" 
WHERE
   "Пользователь" = :ИдКлиента;</body>
      </definition>
    </select>
    <select access_mode="1" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.ПараметрыРоли" responsible="shchukinav" returns="TABLE" type="SQL">
      <parameter name="ИмяРоли">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="Порядок">
        <format>
          <type>DOUBLE</type>
        </format>
      </return>
      <return name="Скрытая">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="ForServiceUsers">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>SELECT "Порядок", "Скрытая", "ForServiceUsers", "Раздел" FROM "ПараметрыРоли" WHERE "Роль" = $1;</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Роли" is_service="1" name="Авторизация.ПроверитьЦиклыДляРодителейУстанавливаемыхРолей" returns="TABLE" type="SQL">
      <parameter name="Родители">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <parameter name="Дети">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <return name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>with recursive T( "БазоваяРоль", "ДочерняяРоль" ) as
(
   SELECT "БазоваяРоль", "ДочерняяРоль" FROM "ЗависимостиРолей"
      WHERE "ДочерняяРоль" = ANY( :Дети )
   UNION
   SELECT zr."БазоваяРоль", zr."ДочерняяРоль" FROM "ЗависимостиРолей" zr
      INNER JOIN T ON zr."ДочерняяРоль" = T."БазоваяРоль"
)
SELECT DISTINCT kr."Имя", kr."Название" from T
   INNER JOIN "КлиентскаяРоль" kr ON T."БазоваяРоль" = kr."Имя"
      WHERE kr."Имя" = ANY( :Родители );</body>
      </definition>
    </select>
    <select access_mode="1" category="Служебные функции" is_service="1" name="Авторизация.РолиПользователей" returns="TABLE" type="SQL">
      <parameter name="Пользователи">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>select ur."Пользователь", ur."Название"
   from "РолиПользователей" ur
      where ur."Пользователь" = any((:Пользователи)::int[])
         order by ur."Пользователь";</body>
      </definition>
    </select>
    <select access_mode="1" category="Служебные функции" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.РолиПользователя" responsible="shabrovaan" returns="TABLE" type="PYTHON">
      <parameter name="ИдПользователя">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="ПраваВПерсональнойСхеме">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <return name="@Пользователь">
        <format>
          <type>INT64</type>
        </format>
      </return>
      <return name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="КлассПользователя">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>if Session.UserID() == ИдПользователя :
   return Авторизация.UserRolesOwn( ПраваВПерсональнойСхеме )
else :
   return Авторизация.UserRoles( ИдПользователя, ПраваВПерсональнойСхеме )</body>
      </definition>
    </select>
    <select access_mode="0" is_proxy="0" is_service="0" last_changed="Щукин А.В." name="Авторизация.СброситьКэш" responsible="Щукин А.В." returns="NONE" type="NATIVE">
      <parameter name="ИдентификаторКлиента">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
    </select>
    <select access_mode="0" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="Авторизация.СброситьКэшиПрав" responsible="Шаброва А.Н." returns="SCALAR" type="NATIVE">
      <comment>Сбрасывает кэши прав всех пользователей и клиентов разом. Поэтому вызывать эту функцию нужно как можно реже.</comment>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
    <select access_mode="1" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.СкрытыеРоли" responsible="Шаброва А.Н." returns="TABLE" type="SQL">
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>SELECT
   "Роль"
FROM
   "ПараметрыРоли"
WHERE
   "Скрытая" AND
   "Пользователь" = :ИдКлиента;</body>
      </definition>
    </select>
    <select access_mode="1" category="Предотвращение самоблокировки" is_proxy="0" is_service="1" last_changed="Буравлев М.С." name="Авторизация.СписокАдминистраторов" responsible="Буравлев М.С." returns="ARRAY" type="NATIVE">
      <parameter name="Клиент">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>INT4[]</type>
        </format>
      </return>
    </select>
    <select access_mode="1" category="Предотвращение самоблокировки" is_service="1" last_changed="Буравлев М.С." name="Авторизация.СписокАдминистраторовБД" responsible="Буравлев М.С." returns="ARRAY" type="SQL">
      <parameter name="РолиАдм">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>INT4[]</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>select array_agg( "@Пользователь" ) from (
   select "@Пользователь"
      from "Пользователь"
         where "Раздел" = current_setting('sbis3.clientID')::integer and
               "Раздел@" IS NULL and
               "НаследоватьПрава" IS TRUE
   UNION
   select DISTINCT ur."Пользователь"
      from "РолиПользователей" ur
         inner join "Пользователь" u on ur."Пользователь" = u."@Пользователь"
            where u."Раздел" = current_setting('sbis3.clientID')::integer and
                  ur."Название" = ANY ( :РолиАдм::text[] )
) T</body>
      </definition>
    </select>
    <select access_mode="1" category="Предотвращение самоблокировки" is_service="1" last_changed="Рыбаков М.А." name="Авторизация.СписокМетодовДляКонроляАдминистратора" responsible="Буравлев М.С." returns="TABLE" type="PYTHON">
      <return name="ПередКакимМетодом">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="МетодОпределенияПользователя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>format = MethodResultFormat('Авторизация.СписокМетодовДляКонроляАдминистратора',0)
rs = RecordSet(format)

i = rs.Size() 
rs.InsRow(i)
rs[i]['ПередКакимМетодом'].From('Пользователь.Записать')
rs[i]['МетодОпределенияПользователя'].From('Пользователь.ИдентификаторПоПараметрамВызоваЗаписать')

i = rs.Size() 
rs.InsRow(i)
rs[i]['ПередКакимМетодом'].From('Пользователь.Удалить')
rs[i]['МетодОпределенияПользователя'].From('Пользователь.ИдентификаторПоПараметрамВызоваУдалить')

i = rs.Size() 
rs.InsRow(i)
rs[i]['ПередКакимМетодом'].From('РолиПользователя.Установить')
rs[i]['МетодОпределенияПользователя'].From('РолиПользователя.ИдентификаторПоПараметрамВызова')

i = rs.Size() 
rs.InsRow(i)
rs[i]['ПередКакимМетодом'].From('Авторизация.УдалитьПользователяОтРоли')
rs[i]['МетодОпределенияПользователя'].From('РолиПользователя.ИдентификаторПоПараметрамВызова')

return rs</body>
      </definition>
    </select>
    <select access_mode="1" category="Предотвращение самоблокировки" is_service="1" last_changed="Буравлев М.С." name="Авторизация.СписокМетодовДляПерерасчетаАдминистраторов" responsible="Буравлев М.С." returns="ARRAY" type="PYTHON">
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>TEXT[]</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return [
'Пользователь.Записать',
'Пользователь.Создать',
'РолиПользователя.Установить',
'РолиПользователя.УстановитьРоль',
'РолиПользователя.ДобавитьПользователей'
]</body>
      </definition>
    </select>
    <select access_mode="1" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.СписокНазначенныхРолей" responsible="Шаброва А.Н." returns="TABLE" type="PYTHON">
      <comment>Возвращает список всех ролей, назначенных для пользователей заданного клиента, не наследующих права. Используется для назначения пересечения ролей по умолчанию при создании нового пользователя.</comment>
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="ИдПользователя">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="ПраваВПерсональнойСхеме">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <return name="@Пользователь">
        <format>
          <type>INT64</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>schema = '' if ПраваВПерсональнойСхеме else 'public.'
query = """select 
   u1."@Пользователь", rp."Название" 
from 
   "Пользователь" as u1 
left join 
   """ + schema + """"РолиПользователей" as rp 
on 
   u1."@Пользователь" = rp."Пользователь" 
where 
   u1."@Пользователь" in (
      select 
         u."@Пользователь" 
      from 
         "Пользователь" as u 
      where 
         u."Раздел" = {Клиент} 
      and 
         u."НаследоватьПрава" is not true 
      and 
         u."@Пользователь" &lt;&gt; {Пользователь}
      and 
         u."$Черновик" is null 
      and 
         u."Заблокирован" is not true 
  )"""

format = MethodResultFormat( "Авторизация.СписокНазначенныхРолей", 3)
return SqlQuery( query.format( Клиент = ИдКлиента, Пользователь = ИдПользователя) , format )</body>
      </definition>
    </select>
    <select access_mode="1" category="Служебные функции" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.СписокЯвноНазначенных" responsible="Шаброва А.Н." returns="RECORD" type="PYTHON">
      <parameter name="ИдПользователя">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="ПраваВПерсональнойСхеме">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <return name="Роли">
        <format>
          <type>TEXT[]</type>
        </format>
      </return>
      <return name="Наследует">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>schema = '' if ПраваВПерсональнойСхеме else 'public.'
query = """select array_agg( r."Название" ) as "Роли", u."НаследоватьПрава" is not distinct from true "Наследует"
  from "Пользователь" u
  left join """ + schema + """"РолиПользователей" r on r."Пользователь" = u."@Пользователь" and u."НаследоватьПрава" is distinct from true
  where u."@Пользователь" = {Пользователь}
  group by u."НаследоватьПрава";"""
   
format = MethodResultFormat( "Авторизация.СписокЯвноНазначенных", 2)
return SqlQueryRecord( query.format( Пользователь = ИдПользователя ) , format )</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.УдалитьКлиентскуюРоль" responsible="Кондратьев М.А." returns="SCALAR" type="PYTHON">
      <transaction type="required"/>
      <parameter name="ИдО">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>import re
fun = lambda res: str( res ) if res is not None else 'null'
roleId = fun( ИдО )
pat = '^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$'
res = bool( re.search(pat, roleId) )
if not res:
   return False
users = SqlQueryScalar( """Select array_agg("Пользователь") from "РолиПользователей" t where t."Название" = '""" + roleId + """';""" )

client_id = SqlQueryScalar( """
delete from "РолиПользователей" t where t."Название" = '""" + roleId + """';
delete from "ЗависимостиРолей" t where t."БазоваяРоль" = '""" + roleId + """' or t."ДочерняяРоль" = '""" + roleId + """';
delete from "НастройкиЗоныДоступа" t where t."Роль" = '""" + roleId + """';
delete from "ПараметрыРоли" t where t."Роль" = '""" + roleId + """';
delete from "КлиентскаяРоль" t where t."Имя" = '""" + roleId + """' returning "Пользователь";""" )

if( client_id is not None ) :
   КэшированиеМетодов.ОчиститьКэшКлиента( client_id, 'Авторизация.НастройкиЗонДоступа', 1)
if users is not None:
   for user in users:
      if user is not None:
         КэшированиеМетодов.ОчиститьКэшПользователя( user, 'Авторизация.UserRolesOwn', 1 )

return True</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Зона доступа" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.УдалитьНастройкиВсехЗонРоли" responsible="Кондратьев М.А." returns="NONE" type="PYTHON">
      <transaction type="required"/>
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: str( res ) if res is not None else 'null'
role = fun( Роль )

SqlQuery( ( """DELETE FROM "НастройкиЗоныДоступа" WHERE "Роль" = '""" + role + """' AND "Пользователь" = {client_id};""" ).format( client_id = ИдКлиента ) )

КэшированиеМетодов.ОчиститьКэшКлиента( ИдКлиента, 'Авторизация.НастройкиЗонДоступа', 1)</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.УдалитьПользователяОтРоли" responsible="Кондратьев М.А." returns="NONE" type="PYTHON">
      <transaction type="required"/>
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="ПраваВПерсональнойСхеме">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>if Пользователь is None or Роль is None:
   return
scheme_str = '' if ПраваВПерсональнойСхеме else 'public.'

SqlQuery( """DELETE FROM """ + scheme_str + """"РолиПользователей" WHERE "Название" = '{role}' AND "Пользователь" = {user};""".format( role=Роль.replace( "'", "''" ), user=Пользователь) )

КэшированиеМетодов.ОчиститьКэшПользователя( Пользователь, 'Авторизация.UserRolesOwn', 1 )</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.УстановитьДетейРоли" responsible="Кондратьев М.А." returns="NONE" type="PYTHON">
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Дети">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: str( res ) if res is not None else 'null'
role = fun( Роль )
children = fun(Дети)[1:-1]
children = children.replace("'",'"')
children = "'{" + children + "}'"

SqlQuery( """
delete from "ЗависимостиРолей" t where t."БазоваяРоль" = '""" + role + """' AND "Пользователь" = """ + str(ИдКлиента) + """;
insert into "ЗависимостиРолей" ( "БазоваяРоль", "ДочерняяРоль", "Пользователь" ) select '""" + role + """', unnest( """ + children + """::text[] ), """ + str(ИдКлиента) + """;""" )</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="Авторизация.УстановитьРодителейРоли" responsible="Кондратьев М.А." returns="NONE" type="PYTHON">
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Родители">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <parameter name="ИдКлиента">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: str( res ) if res is not None else 'null'
role = fun( Роль )
parents = fun(Родители)[1:-1]
parents = parents.replace("'",'"')
parents = "'{" + parents + "}'"

SqlQuery( """
delete from "ЗависимостиРолей" t where t."ДочерняяРоль" = '""" + role + """' AND "Пользователь" = """ + str(ИдКлиента) + """;
insert into "ЗависимостиРолей" ( "БазоваяРоль", "ДочерняяРоль", "Пользователь" ) select unnest( """ + parents + """::text[] ), '""" + role + """', """ + str(ИдКлиента) + """;""" )</body>
      </definition>
    </select>
  </object>

  <object last_changed="Буравлев М.С." name="БазовыйПользователь" responsible="Буравлев М.С.">
    <object last_changed="Буравлев М.С." name="Пользователь" responsible="Буравлев М.С.">
      <history_object>
        <base_table history_type="table" name="Пользователь">
          <link_table history_from_many="0" history_link_condition="Пользователь.@Пользователь=РолиПользователей.Пользователь" history_link_name="@Пользователь" history_link_table="РолиПользователей" history_type="table" name="РолиПользователей"/>
        </base_table>
      </history_object>
    </object>
  </object>

  <object name="ЗонаДоступа">
    <standart_select access_mode="1" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ЗонаДоступа.Список" responsible="Шаброва А.Н." type="NATIVE">
      <return name="Имя">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>HIERARCHY</type>
          <nodes_field>1</nodes_field>
          <hierarchy_name>Название</hierarchy_name>
        </format>
      </return>
      <return name="Примечание">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Доступ">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="НаследуетЧтениеОт">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="НаследуетЗаписьОт">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="НаследуетЗапретОт">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="ЯвноНазначена">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="ОбластиВидимости">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="ОбластиВидимостиNew">
        <format>
          <type>RECORDSET</type>
        </format>
      </return>
      <std_parameter filter_category="USER" name="ИдО" param_type="REQUIRED" type="TEXT"/>
    </standart_select>
  </object>

  <object last_changed="Буравлев М.С." name="КонтрольПравАдминистратора" responsible="Буравлев М.С.">
    <select access_mode="0" is_service="1" last_changed="Буравлев М.С." name="КонтрольПравАдминистратора.КонтрольНаличияАдминистративнойРоли" responsible="Буравлев М.С." returns="RECORD" type="PYTHON">
      <parameter name="параметры">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="МожетВходить">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="ДальшеПроверять">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>outRec = Record()
outRec.AddBool( "МожетВходить", True )
outRec.AddBool( "ДальшеПроверять", True )
outRec.AddString( "Сообщение", "" )

if str( параметры._ИмяВызываемогоМетода ) == 'РолиПользователя.Установить':
   роли = параметры.Роли
   административныеРоли = параметры._АдминистративныеРоли
   
   if( len( list( set( роли ) &amp; set( административныеРоли ) ) ) == 0 ):
      outRec.МожетВходить = False
      outRec.ДальшеПроверять = False
      outRec.Сообщение = "В системе больше нет пользователей с &lt;a target=\"about:blank\" href=\"http://help.sbis.ru/about_edo/configure/user_law\"&gt;максимальными правами&lt;/a&gt;"

return outRec</body>
      </definition>
    </select>
    <select access_mode="0" is_service="1" last_changed="Буравлев М.С." name="КонтрольПравАдминистратора.КонтрольНаличияАдминистративнойРолиПриУдалении" responsible="Буравлев М.С." returns="RECORD" type="PYTHON">
      <parameter name="параметры">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="МожетВходить">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="ДальшеПроверять">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>outRec = Record()
outRec.AddBool( "МожетВходить", True )
outRec.AddBool( "ДальшеПроверять", True )
outRec.AddString( "Сообщение", "" )

if str( параметры._ИмяВызываемогоМетода ) in [ 'РолиПользователя.УдалитьПользователей', 'Авторизация.УдалитьПользователяОтРоли' ]:
   if( str( параметры.Роль ) in list( параметры._АдминистративныеРоли ) ):
      outRec.МожетВходить = False
      outRec.ДальшеПроверять = False
      outRec.Сообщение = "В системе больше нет пользователей с &lt;a target=\"about:blank\" href=\"http://help.sbis.ru/about_edo/configure/user_law\"&gt;максимальными правами&lt;/a&gt;"

return outRec</body>
      </definition>
    </select>
  </object>

  <object name="ОбластьВидимости">
    <select access_mode="0" is_service="1" last_changed="Шаброва А.Н." name="ОбластьВидимости.Вызвать" responsible="Шаброва А.Н." returns="SCALAR" type="PYTHON">
      <cached forwhom="session" lifetime="20"/>
      <parameter name="ОбластьВидимости">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>no_params = Record()
res = BLObject( 'ОбластьВидимости' ).RecInvoke( ОбластьВидимости, no_params )
result = ''

if res is not None : 
   result = '{' + res.__str__() + '}'
else :
   result = 'NULL'
   
return result</body>
      </definition>
    </select>
    <aos_function alias="Роли не больше своих" last_changed="Шаброва А.Н." name="ОбластьВидимости.НазначениеРолейНеБольшеСвоих" responsible="Шаброва А.Н." return="INT4[]" transactionVariableName="appointmentMoreRoles" type="PYTHON">
      <body>return None</body>
    </aos_function>
    <select access_mode="0" category="Работа с нашими организация" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ОбластьВидимости.СохранитьОрганизации" responsible="Шаброва А.Н." returns="SCALAR" type="NATIVE">
      <parameter name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="Организации">
        <format>
          <type>INT4[]</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <area_of_sight alias="ОбластьВидимости.ДокументыМоегоОфиса" name="ОбластьВидимости.ДокументыМоегоОфиса"/>
    </select>
    <select access_mode="0" category="Работа с нашими организация" is_service="1" last_changed="Шаброва А.Н." name="ОбластьВидимости.СохранитьОрганизацииСлужебный" responsible="Кондратьев М.А." returns="NONE" type="PYTHON">
      <parameter name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="Организации">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: str( res ) if res is not None else '{}'
usr = fun( Пользователь )
orgs = fun( Организации )
orgs = orgs.replace('\\\\\\','\\')
orgs_ = orgs
flags = '-+---'
if orgs == 'ВсеОрганизации' :
   orgs_ = '{}'
   flags = '+----'
SqlQuery( """
DELETE FROM "НастройкиЗоныДоступа" WHERE "Пользователь" = """ + usr + """ AND "AosFunction" = 'ОбластьВидимости.НашиОрганизации' AND "Роль" IS NULL;
INSERT INTO "НастройкиЗоныДоступа" ( "Пользователь", "AosFunction", "ScopeFlags", "Settings" ) VALUES( """ + usr + """, 'ОбластьВидимости.НашиОрганизации', '""" + flags + """', '""" + orgs_ + """'::integer[] );""" )</body>
      </definition>
    </select>
    <select access_mode="0" category="Работа с подразделениями" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ОбластьВидимости.СохранитьПодразделения" responsible="Шаброва А.Н." returns="SCALAR" type="NATIVE">
      <parameter name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="Подразделения">
        <format>
          <type>INT4[]</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <area_of_sight alias="ОбластьВидимости.ДокументыМоегоОфиса" name="ОбластьВидимости.ДокументыМоегоОфиса"/>
    </select>
    <select access_mode="0" category="Работа с подразделениями" is_service="1" last_changed="Шаброва А.Н." name="ОбластьВидимости.СохранитьПодразделенияСлужебный" responsible="Кондратьев М.А." returns="NONE" type="PYTHON">
      <parameter name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="Подразделения">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: str( res ) if res is not None else '{}'
usr = fun( Пользователь )
units = fun( Подразделения )
units = units.replace('\\\\\\','\\')
unts = units
flags = '-+-++'
if units == 'ВсеПодразделения' :
   flags = '+----'
   unts = '{}'
else :
   if units == 'МойОфис' :
      flags = '---++'
      unts = '{}'
SqlQuery( """
DELETE FROM "НастройкиЗоныДоступа" WHERE "Пользователь" = """ + usr + """ AND "AosFunction" = 'ОбластьВидимости.ДокументыМоегоОфиса' and "Роль" IS NULL;
INSERT INTO "НастройкиЗоныДоступа" ( "Пользователь", "AosFunction", "ScopeFlags", "Settings" ) VALUES ( """ + usr + """, 'ОбластьВидимости.ДокументыМоегоОфиса', '""" + flags + """', '""" + unts + """'::integer[] );""" )</body>
      </definition>
    </select>
    <standart_select access_mode="1" category="Работа с подразделениями" is_service="1" last_changed="Шаброва А.Н." name="ОбластьВидимости.СписокКорневыхПодразделений" responsible="Шаброва А.Н." type="PYTHON">
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>user_str = str( Фильтр.Пользователь )
res = SqlQueryScalar( """
WITH RECURSIVE rights AS (
	-- сохраняем назначенные права пользователя
	SELECT
		"Настройки"::hstore-&gt;'Подразделение' rgh,
      CASE
			WHEN ("Настройки"::hstore-&gt;'Подразделение') ~ E'^\{(\\\\d+|,)*\}$' THEN ("Настройки"::hstore-&gt;'Подразделение')::integer[]
		END ids -- назначен набор подразделений
	FROM
		"НастройкиОВПользователя"
	WHERE
		("ОбластьВидимости", "Пользователь") = ('ДокументыМоегоОфиса', """ + user_str + """ )
),
-- определение привязанной структуры предприятия пользователя
office AS (
   WITH RECURSIVE spr AS (
      SELECT
         "@Лицо", "Раздел", "ОфисПродаж" 
      FROM
         "СтруктураПредприятия"
      WHERE
         "@Лицо" = (
   						CASE 
                     WHEN ( 
                        SELECT  
         				      pr."Значение"
         				   FROM 
         				      "Параметр" pr
         				   WHERE 
         				      pr."ИдПользователь" IS NULL AND pr."Название" = 'РежимОтображенияСпискаСотрудников' and pr."Раздел" IS NULL 
         				   LIMIT 1 ) = 'Все'
                     THEN 
                        -- Управленческое подразделение
                        (
                           SELECT
         							"СтруктураПредприятия"
         						FROM
         							"СвязиПользователя"
         						WHERE
         							"Пользователь" = """ + user_str + """ AND
         							"УправленческаяСтруктура"
         						LIMIT 1
                        )
                     ElSE
                        -- Подразделение в структуре по Юр лицам
                       (
                          SELECT
         							SP."СтруктураПредприятия"
         						FROM
         							"СвязиПользователя" SP_UPR
         							JOIN "СвязиПользователя" SP ON SP_UPR."ЧастноеЛицо" = SP."ЧастноеЛицо"
         							LEFT JOIN "ДолжностьСотрудника" DS ON SP."ДолжностьСотрудника" = DS."@ДолжностьСотрудника"
         							
         						WHERE
         							SP_UPR."Пользователь" = """ + user_str + """
         							AND
         							SP_UPR."УправленческаяСтруктура"
         							AND 
         							SP."УправленческаяСтруктура" IS FALSE
         							AND 
         							( SP."ДолжностьСотрудника" IS NULL OR  DS."ДатаСнятия" IS NULL )
         							
         						LIMIT 1
                         )
   		             END 		
                )
      UNION ALL
				SELECT
					sp."@Лицо", sp."Раздел", sp."ОфисПродаж"
				FROM
					spr
				INNER JOIN
					"СтруктураПредприятия" sp
						ON sp."@Лицо" = spr."Раздел" -- идем вверх до ближайшего офиса
				WHERE
					spr."ОфисПродаж" IS NULL
   )
	SELECT * FROM spr WHERE "ОфисПродаж" IS NOT NULL LIMIT 1
)
(
	-- NULL == все разрешено
SELECT NULL "Подразделения" WHERE ( SELECT rgh FROM rights LIMIT 1 ) = 'ВсеПодразделения'
UNION ALL
	(
      -- NULL == все разрешено, если офиса не нашли
      SELECT NULL "Подразделения" WHERE NOT EXISTS( SELECT NULL FROM office LIMIT 1 )
		UNION ALL
			(
				-- набираем дочерние подразделения своего офиса
				WITH RECURSIVE children AS (
					SELECT
						"@Лицо", "Раздел"
					FROM
						office
				UNION ALL
					SELECT
						sp."@Лицо", sp."Раздел"
					FROM
						children
					INNER JOIN
						"СтруктураПредприятия" sp
							ON sp."Раздел" = children."@Лицо" -- идем вниз до конца
				)
				-- набираем дочерние подразделения вручную разрешенных подразделений (если они есть)
				, manual AS (
					SELECT
						"@Лицо", "Раздел"
					FROM
						"СтруктураПредприятия"
					WHERE
						(SELECT ids IS NOT NULL FROM rights LIMIT 1) AND
						"@Лицо" = ANY((SELECT ids FROM rights LIMIT 1)::integer[])
				UNION ALL
					SELECT
						sp."@Лицо", sp."Раздел"
					FROM
						manual
					INNER JOIN
						"СтруктураПредприятия" sp
							ON sp."Раздел" = manual."@Лицо" -- идем вниз до конца
					WHERE
						(SELECT ids IS NOT NULL FROM rights LIMIT 1)
				)
				SELECT
					ARRAY(
						SELECT "@Лицо" FROM children
					   UNION
						SELECT "@Лицо" FROM manual
					)
			)
	)
)
LIMIT 1;""")

if res is None:
   res_format = CreateRecordFormat()
   res_format.AddString( "Название" )
   result = CreateRecordSet( res_format )
   rec = CreateRecord( res_format ) 
   rec['Название'].From( 'Все подразделения' )
   result.InsRow( 0, rec )      
   return result
else:
   return SqlQuery('''SELECT T."Название" FROM (
                                          SELECT 
                                             s1."@Лицо" as "@Лицо", s1."Раздел" as "Раздел", s1."Название" as "Название"
                                          FROM 
                                             "СтруктураПредприятия" s1
                                          WHERE 
                                             s1."@Лицо" = ANY( ARRAY{my_office} )
                                  
                                        ) T
                                       WHERE 
                                           T."Раздел" IS NULL OR T."Раздел" &lt;&gt; ALL( ARRAY{my_office} )'''.format( my_office=str(res) ) )</body>
      </definition>
      <std_parameter filter_category="USER" name="Пользователь" param_type="REQUIRED" type="INTEGER"/>
    </standart_select>
    <standart_select access_mode="1" category="Работа с нашими организация" is_service="0" last_changed="Шаброва А.Н." name="ОбластьВидимости.СписокОрганизаций" responsible="Buravlevms" type="SQL">
      <return name="@Лицо">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>WITH 
	getUnitSettings AS (
		SELECT "ScopeFlags", "Settings" as userSettings
			FROM "НастройкиЗоныДоступа"
				WHERE "Пользователь" = (:Пользователь)::integer AND "AosFunction" = 'ОбластьВидимости.НашиОрганизации' AND "Роль" IS NULL AND "AccessArea" IS NULL
	),
	unitSettingsUnnest AS (
		SELECT unnest( U.userSettings::INTEGER[] ) as faceArray
			FROM getUnitSettings U
	)
	SELECT '0,ВсеОрганизации'::TEXT as "@Лицо",'Все организации'::TEXT as "Название" 
		WHERE ( SELECT  COUNT ( * ) = 0 FROM getUnitSettings ) OR EXISTS( SELECT U."ScopeFlags" FROM getUnitSettings U WHERE U."ScopeFlags" LIKE '+%') 
	UNION
	SELECT T1."@Лицо"::TEXT as "@Лицо", T2."Название"::text AS "Название"
		FROM "НашаОрганизация" T1
			JOIN unitSettingsUnnest x ON T1."@Лицо" = x.faceArray				
				LEFT JOIN "Контрагент" T2 ON T1."@Лицо" = T2."@Лицо"</body>
      </definition>
      <std_parameter filter_category="USER" name="Пользователь" param_type="REQUIRED" type="INTEGER"/>
    </standart_select>
    <standart_select access_mode="1" category="Работа с подразделениями" is_service="0" last_changed="Шаброва А.Н." name="ОбластьВидимости.СписокПодразделений" responsible="Кондратьев М.А." type="SQL">
      <return name="@Лицо">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Тип">
        <format>
          <type>INT16</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>WITH 
	getUnitSettings AS (
                SELECT "ScopeFlags", "Settings" as userSettings
		FROM "НастройкиЗоныДоступа"
		WHERE "Пользователь" = :Пользователь AND "AosFunction" = 'ОбластьВидимости.ДокументыМоегоОфиса' AND "Роль" IS NULL AND "AccessArea" IS NULL
	),	
	unitSettingsUnnest AS (
		SELECT unnest( U.userSettings::INTEGER[] ) as faceArray
		FROM getUnitSettings U
	)

	SELECT '0,МойОфис'::TEXT as "@Лицо",'Свой Офис'::TEXT as "Название", NULL::smallint as "Тип"
	WHERE ( SELECT  COUNT ( * ) = 0 FROM getUnitSettings ) OR EXISTS( SELECT U."ScopeFlags" FROM getUnitSettings U WHERE U."ScopeFlags" LIKE '---+%' )
UNION
	SELECT '0,ВсеПодразделения'::TEXT  as "@Лицо",'Все Подразделения'::TEXT as "Название", NULL::smallint as "Тип"
	FROM getUnitSettings USU
	WHERE  EXISTS( SELECT U."ScopeFlags" FROM getUnitSettings U WHERE U."ScopeFlags" LIKE '+%' )
UNION
	SELECT T."@Лицо"::TEXT || ',СтруктураПредприятия' as "@Лицо", T."Название" as "Название", T."Тип"
	FROM "СтруктураПредприятия" T
	 JOIN unitSettingsUnnest x ON T."@Лицо" = x.faceArray</body>
      </definition>
      <std_parameter filter_category="USER" name="Пользователь" param_type="REQUIRED" type="INTEGER"/>
    </standart_select>
  </object>

  <object last_changed="Шаброва А.Н." name="ОграниченияЛицензией" responsible="Шаброва А.Н.">
    <select access_mode="0" is_service="1" last_changed="Рыбаков М.А." name="ОграниченияЛицензией.ПраваПользователей" responsible="Шаброва А.Н." returns="TABLE" type="PYTHON">
      <parameter name="Лицензия">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="ЗонаДоступа">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="СпособДоступа">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>rec = Record()
rec.AddString( 'ЗонаДоступа' )
rec.AddInt32( 'СпособДоступа' )
res_rs = RecordSet( rec.Format() )
if Лицензия.TestField( 'ПРАВА_ПОЛЬЗОВАТЕЛЕЙ' ) is None or Лицензия[ 'ПРАВА_ПОЛЬЗОВАТЕЛЕЙ' ].__str__().lower() == 'false' or Лицензия[ 'ПРАВА_ПОЛЬЗОВАТЕЛЕЙ' ].__str__().lower() == 'нет':
   rec[ 'ЗонаДоступа' ] = 'Редактирование прав сотрудников'
   rec[ 'СпособДоступа' ] = 1
   res_rs.InsRow( 0, rec )
   rec[ 'ЗонаДоступа' ] = 'Роли'
   rec[ 'СпособДоступа' ] = 1
   res_rs.InsRow( 1, rec )
return res_rs</body>
      </definition>
    </select>
  </object>

  <object name="ПроверкаПрав">
    <select access_mode="0" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ПроверкаПрав.AosValuesForAccessArea" responsible="Шаброва А.Н." returns="SCALAR" type="NATIVE">
      <parameter name="aos_function">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="access_area">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>TEXT</type>
        </format>
      </return>
    </select>
    <select access_mode="0" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ПроверкаПрав.AosValuesForMethod" responsible="Шаброва А.Н." returns="SCALAR" type="NATIVE">
      <parameter name="aos_function">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="method_name">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="args_count">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>TEXT</type>
        </format>
      </return>
    </select>
    <select access_mode="0" is_proxy="0" is_service="1" last_changed="Шаброва А.Н." name="ПроверкаПрав.CheckAcceessAreaForUser" responsible="Шаброва А.Н." returns="SCALAR" type="NATIVE">
      <comment>Метод, который проверяет права на зону доступа не для текущего пользователя:
0 - запрещено
1 - чтение
2 - запись</comment>
      <parameter name="Пользователь">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="ЗонаДоступа">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>INT16</type>
        </format>
      </return>
    </select>
    <select access_mode="1" is_proxy="0" is_service="0" name="ПроверкаПрав.ДоступностьМетода" returns="SCALAR" type="NATIVE">
      <parameter name="ИмяМетода">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ЧислоАргументов">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
    <standart_select access_mode="1" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ПроверкаПрав.ДоступныеЗоныДоступа" responsible="shabrovaan" type="NATIVE">
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="СпособДоступа">
        <format>
          <type>INT16</type>
        </format>
      </return>
    </standart_select>
    <standart_select access_mode="1" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ПроверкаПрав.ДоступныеЗоныСВложением" responsible="shabrovaan" type="NATIVE">
      <comment>Возвращает список всех доступных зон доступа для класса пользователей и разрешение на зону с учетом вложенности (используется для визуальных прав в аккордеоне)</comment>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Доступна">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </standart_select>
    <select access_mode="1" is_proxy="0" is_service="0" last_changed="shabrovaan" name="ПроверкаПрав.НаличиеДействия" responsible="shabrovaan" returns="SCALAR" type="NATIVE">
      <parameter name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>INT16</type>
        </format>
      </return>
    </select>
    <select access_mode="1" is_service="0" last_changed="Кондратьев М.А." name="ПроверкаПрав.НаличиеРолиУТекущегоПользователя" responsible="Кондратьев М.А." returns="SCALAR" type="SQL">
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>WITH hier AS (
	WITH RECURSIVE T ( "razdel" , inher, "cnt") AS 
	(
		SELECT current_setting('sbis3.userID')::integer razdel, "НаследоватьПрава" inher,  1
		FROM "Пользователь"
      WHERE "@Пользователь" = current_setting('sbis3.userID')::INTEGER
	UNION
		SELECT u."Раздел" "razdel", u."НаследоватьПрава" inher,T.cnt + 1
		FROM "Пользователь" u, T
		WHERE u."@Пользователь" = T."razdel" AND u."Раздел" IS NOT NULL AND NOT ( 
         select ( 
            ( select case when "Логин" is null then '' else "Логин" end from "Пользователь" where "@Пользователь" = T."razdel" ) IN 
            ( '__сбис__клиенты','__сбис__администратор','__сбис__гость','__сбис__сервисы','__сбис__демоклиенты','__сбис__cвободныеклиенты','__сбис__удаленные' )
         ) 
      ) and T.inher
      )
	SELECT "razdel" FROM T ORDER BY "cnt" DESC LIMIT 1
)
   
SELECT 	( 
					CASE WHEN ( 
                           select ( 
                                  ( select case when "Логин" is null then '' else "Логин" end from "Пользователь" where "@Пользователь" = ( SELECT "razdel" FROM hier) ) IN 
                                  ( '__сбис__клиенты','__сбис__администратор','__сбис__гость','__сбис__сервисы','__сбис__демоклиенты','__сбис__cвободныеклиенты','__сбис__удаленные' )
                           ) 
                         )
						THEN TRUE::BOOLEAN
							ELSE ( 
                        SELECT EXISTS(
	                          SELECT "@РолиПользователей"
FROM "РолиПользователей"
	                          WHERE  "Название" = :Роль
			                           AND "Пользователь" = ( SELECT "razdel" FROM hier )
			                           AND "@РолиПользователей" IS NOT NULL 
	                     )
                        OR FALSE::BOOLEAN
                     )
					END 
			)
;</body>
      </definition>
    </select>
    <select access_mode="0" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ПроверкаПрав.ОбластиВидимости" responsible="Шаброва А.Н." returns="ARRAY" type="NATIVE">
      <parameter name="ИмяМетода">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ЧислоАргументов">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>TEXT[]</type>
        </format>
      </return>
    </select>
    <select access_mode="0" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ПроверкаПрав.ОбластьВидимостиДляМетода" responsible="Шаброва А.Н." returns="SCALAR" type="NATIVE">
      <parameter name="ОбластьВидимости">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ИмяМетода">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ЧислоАргументов">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
    <select access_mode="1" is_proxy="0" is_service="0" last_changed="shabrovaan" name="ПроверкаПрав.ПраваНаЗонуДоступа" responsible="shabrovaan" returns="ARRAY" type="NATIVE">
      <parameter name="ЗоныДоступа">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOL[]</type>
        </format>
      </return>
    </select>
    <select access_mode="1" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ПроверкаПрав.СостояниеЛицензии" responsible="Шаброва А.Н." returns="SCALAR" type="NATIVE">
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
    <select access_mode="1" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="ПроверкаПрав.СписокЗонДоступаДляМетода" responsible="Шаброва А.Н." returns="TABLE" type="NATIVE">
      <comment>НЕ ИСПОЛЬЗОВАТЬ НА ПОСТОЯННОЙ ОСНОВЕ! ВЫЗЫВАТЬ ТОЛЬКО ЕСЛИ "НЕПОНИМАЮ ОТКУДА ТАКИЕ ПРАВА!".
Метод рассчитывает (с нуля) полный список зон доступа с областями видимости, от которых идет прямое разрешение на объект/метод. В качестве параметра принимает имя метода (Документ.Список) и количество аргументов</comment>
      <parameter name="ИмяМетода">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="КоличествоАргуметов">
        <format>
          <type>INT16</type>
        </format>
      </parameter>
      <return name="ЗонаДоступа">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Служебная">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="ОбластиВидимости">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="СпособДоступа">
        <format>
          <type>INT16</type>
        </format>
      </return>
      <return name="СпособДоступаОтЛицензии">
        <format>
          <type>INT16</type>
        </format>
      </return>
      <return name="МетодРазрешен">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
  </object>

  <object insert_on_create="0" name="РолиПользователя" read_only="0">
    <source name="РолиПользователей"/>
    <standart_select access_mode="1" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="РолиПользователя.PersonalRights" responsible="Шаброва А.Н." type="NATIVE">
      <return name="Имя">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Доступ">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>HIERARCHY</type>
          <nodes_field>1</nodes_field>
          <hierarchy_name>Название</hierarchy_name>
        </format>
      </return>
      <std_parameter filter_category="USER" name="АдресСервиса" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="user_id" param_type="REQUIRED" type="INT64"/>
      <std_parameter filter_category="USER" name="roles" param_type="OPTIONAL" type="TEXT[]"/>
    </standart_select>
    <select access_mode="1" is_proxy="0" is_service="0" last_changed="Желдокас С.А." name="РолиПользователя.getRoleNameByIdentifier" responsible="Желдокас С.А." returns="TABLE" type="NATIVE">
      <parameter name="roleIdentifiers">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <parameter name="clientID">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="ID">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Name">
        <format>
          <type>TEXT</type>
        </format>
      </return>
    </select>
    <select access_mode="0" is_service="0" last_changed="Рыбаков М.А." name="РолиПользователя.ВсеПользователиОфиса" responsible="Кондратьев М.А." returns="NONE" type="PYTHON">
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Пользователи">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: res if res is not None else 'null'
users = fun( Пользователи )
Роль = fun( Роль )
usrList = ''
spList = ''

if users == 'null' or Роль == 'null':
   return []

for item in users:
   item = item.split(',')
   
   if item[1] == 'Пользователь':
      usrList += str( item[0] ) + ','
   else:
      spList += str( item[0] ) + ','

spList = spList[:-1]

if len( spList ) &gt; 0:
   queryText = """
   WITH RECURSIVE T ( "razdel" ) as 
   (
   	SELECT "@Лицо" razdel
   	FROM "СтруктураПредприятия"
   	WHERE "@Лицо" IN ( """ + spList + """ )
   
   UNION
   
   	SELECT sp."@Лицо" "razdel"
   	FROM "СтруктураПредприятия" sp, T
   	WHERE sp."Раздел" IS NOT NULL AND sp."Раздел" = T."razdel"
   ) 
   
   SELECT "@Пользователь"
   FROM "Пользователь" u
   LEFT JOIN "СвязиПользователя" ul ON u."@Пользователь" = ul."Пользователь"
   WHERE ul."СтруктураПредприятия" IN (SELECT "razdel" FROM T)
   """
   res = SqlQuery(queryText)
   curs = res.Cursor()   
   
   while curs.Next():
      data = curs.Data()
      usrList += str( data['@Пользователь'] ) + ','

usrList = usrList[:-1]

if not usrList: return

allUsers = []
usrList = usrList.split(',')

for item in usrList:
   allUsers.append( int( item ) )

allUsers = list( set( allUsers ) )

РолиПользователя.ДобавитьПользователей( Роль, allUsers )</body>
      </definition>
    </select>
    <select access_mode="0" is_proxy="0" is_service="0" name="РолиПользователя.ДобавитьПользователей" returns="NONE" type="NATIVE">
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Пользователи">
        <format>
          <type>INT4[]</type>
        </format>
      </parameter>
    </select>
    <generate_method last_changed="Шаброва А.Н." name="РолиПользователя.Записать" responsible="Шаброва А.Н.">
      <method_hadler name="СброситьКэшПравНаЗаписать">
        <type>ПослеЗаписать</type>
        <order>BEFORE_PARENT</order>
        <impl_handler>NATIVE</impl_handler>
      </method_hadler>
    </generate_method>
    <select access_mode="1" is_service="1" last_changed="Буравлев М.С." name="РолиПользователя.ИдентификаторПоПараметрамВызова" responsible="Буравлев М.С." returns="ARRAY" type="PYTHON">
      <parameter name="параметры">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>INT4[]</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return [ int( параметры.Пользователь ) ]</body>
      </definition>
    </select>
    <select access_mode="0" category="Предотвращение самоблокировки" is_service="0" last_changed="Буравлев М.С." name="РолиПользователя.ИдентификаторПоПараметрамВызоваУдаления" responsible="Буравлев М.С." returns="ARRAY" type="PYTHON">
      <parameter name="параметры">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>INT4[]</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return list( параметры.Пользователи )</body>
      </definition>
    </select>
    <generate_method name="РолиПользователя.История"/>
    <generate_method name="РолиПользователя.Копировать"/>
    <select access_mode="0" is_proxy="0" is_service="0" name="РолиПользователя.МожноЛиУстановить" returns="SCALAR" type="NATIVE">
      <comment>Проверяет, возможно ли установить данному пользователю указанный список ролей. Если пользователь до этого был последним администратором у клиента и роли администратор в списке ролей нет, то метод вернет отрицательный ответ</comment>
      <parameter name="Пользователь">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="Роли">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
    <generate_method name="РолиПользователя.Объединить"/>
    <generate_method name="РолиПользователя.Прочитать"/>
    <declarative key="@РолиПользователей" last_changed="Ткачук М.И." module_api_part="1" name="РолиПользователя.РолиПользователя" responsible="Ткачук М.И." type="1">
      <field>@РолиПользователей</field>
      <field>Название</field>
      <source name="РолиПользователей"/>
      <parameter default="Пользователь" filter_category="SOFTWARE" filter_class="0" name="ИмяПоляСвязи" param_type="CONSTANT" type="STRING"/>
    </declarative>
    <generate_method last_changed="Шаброва А.Н." name="РолиПользователя.Создать" responsible="Шаброва А.Н.">
      <method_hadler name="СброситьКэшПравНаСоздать">
        <type>ПослеСоздать</type>
        <order>BEFORE_PARENT</order>
        <impl_handler>NATIVE</impl_handler>
      </method_hadler>
    </generate_method>
    <generate_method last_changed="Шаброва А.Н." name="РолиПользователя.Удалить" responsible="Шаброва А.Н.">
      <method_hadler name="СброситьКэшПравНаУдалить">
        <type>ПередУдалить</type>
        <order>BEFORE_PARENT</order>
        <impl_handler>NATIVE</impl_handler>
      </method_hadler>
    </generate_method>
    <select access_mode="0" is_proxy="0" is_service="0" name="РолиПользователя.УдалитьПользователей" returns="NONE" type="NATIVE">
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Пользователи">
        <format>
          <type>INT4[]</type>
        </format>
      </parameter>
    </select>
    <select access_mode="0" is_proxy="0" is_service="0" last_changed="Ткачук М.И." module_api_part="1" name="РолиПользователя.Установить" responsible="shabrovaan" returns="SCALAR" type="NATIVE">
      <parameter name="Пользователь">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <parameter name="Роли">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <area_of_sight alias="ОбластьВидимости.НазначениеРолейНеБольшеСвоих" name="ОбластьВидимости.НазначениеРолейНеБольшеСвоих"/>
      <area_of_sight alias="ОбластьВидимости.ДокументыМоегоОфиса" name="ОбластьВидимости.ДокументыМоегоОфиса"/>
    </select>
    <select access_mode="0" is_proxy="0" is_service="1" last_changed="Шаброва А.Н." name="РолиПользователя.УстановитьПоУмолчанию" responsible="Шаброва А.Н." returns="SCALAR" type="NATIVE">
      <parameter name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
    <select access_mode="0" is_proxy="0" is_service="1" last_changed="kuznecovap" name="РолиПользователя.УстановитьРоль" responsible="kuznecovap" returns="SCALAR" type="NATIVE">
      <parameter name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
    <select access_mode="0" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="РолиПользователя.УстановитьРольСлужебный" responsible="kuznecovap" returns="SCALAR" type="PYTHON">
      <transaction type="required"/>
      <parameter name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: str( res ) if res is not None else 'null'
userID = fun( Пользователь )
userRole = fun( Роль )
res = SqlQueryScalar( """select exists( SELECT 1 FROM "РолиПользователей" WHERE "Пользователь" = """ + userID + """ AND "Название" = '""" + userRole + """')""" )
if not res:
   SqlQuery( """INSERT INTO "РолиПользователей" ("Пользователь", "Название") VALUES (""" + userID + """, '""" + userRole + """');""" )
   КэшированиеМетодов.ОчиститьКэшПользователя( Пользователь, "Авторизация.UserRolesOwn", 1 )
return True</body>
      </definition>
    </select>
    <select access_mode="0" category="Служебные функции Роли" is_service="1" last_changed="Шаброва А.Н." name="РолиПользователя.УстановитьСлужебный" responsible="Кондратьев М.А." returns="SCALAR" type="PYTHON">
      <transaction type="required"/>
      <parameter name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <parameter name="Роли">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <parameter name="ПраваВПерсональнойСхеме">
        <format>
          <type>BOOLEAN</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>fun = lambda res: str( res ) if res is not None else 'null'
userID = fun( Пользователь )
roles = fun(Роли)[1:-1]
roles = roles.replace("'",'"')
roles = "'{" + roles + "}'"
scheme_str = '' if ПраваВПерсональнойСхеме else 'public.'

SqlQuery( """
delete from """ + scheme_str + """"РолиПользователей" t where t."Пользователь" = """ + userID + """;
insert into """ + scheme_str + """"РолиПользователей" ("Пользователь", "Название") select """ + userID + """, unnest(""" + roles + """::text[])""" )

КэшированиеМетодов.ОчиститьКэшПользователя( Пользователь, "Авторизация.UserRolesOwn", 1 )

return True</body>
      </definition>
    </select>
    <standart_select access_mode="1" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="РолиПользователя.ЧтоМожно" responsible="shabrovaan" type="NATIVE">
      <return name="Имя">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Доступ">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>HIERARCHY</type>
          <nodes_field>1</nodes_field>
          <hierarchy_name>Название</hierarchy_name>
        </format>
      </return>
      <std_parameter filter_category="USER" name="Роли" param_type="OPTIONAL" type="TEXT[]"/>
      <std_parameter filter_category="USER" name="Пользователь" param_type="REQUIRED" type="INT64"/>
      <std_parameter filter_category="USER" name="АдресСервиса" param_type="OPTIONAL" type="TEXT"/>
    </standart_select>
  </object>

  <object name="Роль">
    <select access_mode="1" is_service="1" last_changed="Шаброва А.Н." name="Роль.UserCountByRoles" responsible="Шаброва А.Н." returns="TABLE" type="SQL">
      <parameter name="ClientID">
        <format>
          <type>INT64</type>
        </format>
      </parameter>
      <return name="id">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="count">
        <format>
          <type>INT64</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>WITH RECURSIVE T (
   "@Пользователь", 
   "Имя",
   "Логин",
   "Раздел", 
   "Раздел@", 
   "НаследоватьПрава", 
   "$Черновик",
   "Заблокирован"
) AS (
   SELECT 
      u."@Пользователь", 
      u."Имя",
      u."Логин",
      u."Раздел", 
      u."Раздел@", 
      u."НаследоватьПрава", 
      u."$Черновик",
      u."Заблокирован"
   FROM 
      "Пользователь" u 
   WHERE 
       u."@Пользователь" = :ClientID
   UNION
   SELECT 
      u."@Пользователь", u."Имя", u."Логин",
      u."Раздел", u."Раздел@", 
      u."НаследоватьПрава", 
      u."$Черновик",
      u."Заблокирован"
   FROM 
      "Пользователь" u 
   JOIN 
      T
   ON 
      u."Раздел" = T."@Пользователь"
) 
SELECT 
  R."Название" as "id", count( T."@Пользователь" ) as "count"
FROM 
   T 
LEFT JOIN 
   "РолиПользователей" R
ON
   T."@Пользователь" = R."Пользователь"
WHERE 
   T."Раздел@" IS NULL 
   AND 
   T."$Черновик" IS NULL
   AND 
   T."Заблокирован" IS NOT TRUE
   AND
   T."НаследоватьПрава" IS NOT TRUE 
   AND
   R."Название" IS NOT NULL 
   GROUP BY R."Название"
UNION
   SELECT null as "id", count( T."@Пользователь" ) as "count"
   FROM T
   WHERE
   T."Раздел@" IS NULL 
   AND 
   T."$Черновик" IS NULL
   AND 
   T."Заблокирован" IS NOT TRUE
   AND
   T."НаследоватьПрава" IS TRUE</body>
      </definition>
    </select>
    <select access_mode="0" is_proxy="0" is_service="0" name="Роль.Записать" returns="SCALAR" type="NATIVE">
      <parameter name="Запись">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>TEXT</type>
        </format>
      </return>
    </select>
    <select access_mode="1" is_proxy="0" is_service="0" name="Роль.ЗоныРоли" returns="TABLE" type="NATIVE">
      <parameter name="Роль">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <return name="ЗонаДоступа">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="НаследуетЧтениеОт">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="НаследуетЗаписьОт">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="НаследуетЗапретОт">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="ОбластиВидимости">
        <format>
          <type>TEXT</type>
        </format>
      </return>
    </select>
    <standart_select access_mode="1" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="Роль.НазначенаПользователям" responsible="Шаброва А.Н." type="NATIVE">
      <return name="@Пользователь">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>HIERARCHY</type>
          <nodes_field>1</nodes_field>
          <hierarchy_name>Имя</hierarchy_name>
        </format>
      </return>
      <return name="Раздел@">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <std_parameter filter_category="USER" name="Роль" param_type="REQUIRED" type="TEXT"/>
      <std_parameter filter_category="USER" name="Имя" param_type="OPTIONAL" type="TEXT">
        <comment>Поиск по имени или логину</comment>
      </std_parameter>
      <std_parameter filter_category="USER" name="ИдПользователя" param_type="OPTIONAL" type="INT64"/>
      <std_parameter filter_category="USER" name="АдресСервиса" param_type="OPTIONAL" type="TEXT"/>
    </standart_select>
    <select access_mode="1" is_proxy="0" is_service="0" name="Роль.ПроверитьСуществование" returns="SCALAR" type="NATIVE">
      <parameter name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
    <select access_mode="1" is_service="0" last_changed="Шаброва А.Н." name="Роль.ПроверитьЦиклы" responsible="Шаброва А.Н." returns="TABLE" type="SQL">
      <parameter name="Роль">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Дети">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <return name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>with recursive T( "БазоваяРоль", "ДочерняяРоль" ) as
(
   SELECT "БазоваяРоль", "ДочерняяРоль" FROM "ЗависимостиРолей"
      WHERE "ДочерняяРоль" = :Роль
   UNION
   SELECT zr."БазоваяРоль", zr."ДочерняяРоль" FROM "ЗависимостиРолей" zr
      INNER JOIN T ON zr."ДочерняяРоль" = T."БазоваяРоль"
)
SELECT DISTINCT kr."Имя", kr."Название" from T
   INNER JOIN "КлиентскаяРоль" kr ON T."БазоваяРоль" = kr."Имя"
      WHERE kr."Имя" = ANY( :Дети );</body>
      </definition>
    </select>
    <select access_mode="1" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="Роль.Прочитать" responsible="Шаброва А.Н." returns="RECORD" type="NATIVE">
      <parameter name="ИдО">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ИмяМетода">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <return name="@Роль">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Примечание">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>HIERARCHY</type>
          <nodes_field>1</nodes_field>
          <hierarchy_name>Название</hierarchy_name>
        </format>
      </return>
      <return name="Скрытая">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Системная">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="СписокЗон">
        <format>
          <type>RECORDSET</type>
        </format>
      </return>
      <return name="Родители">
        <format>
          <type>RECORDSET</type>
        </format>
      </return>
      <return name="Наследники">
        <format>
          <type>RECORDSET</type>
        </format>
      </return>
      <return name="ForServiceUsers">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
    <select access_mode="0" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="Роль.Создать" responsible="Буравлев М.С." returns="RECORD" type="NATIVE">
      <parameter name="ИмяМетода">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Фильтр">
        <format>
          <type>RECREFERENCE</type>
          <free>1</free>
        </format>
      </parameter>
      <return name="@Роль">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Примечание">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>HIERARCHY</type>
          <nodes_field>1</nodes_field>
          <hierarchy_name>Название</hierarchy_name>
        </format>
      </return>
      <return name="Скрытая">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Системная">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="ForServiceUsers">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="hierRole">
        <format>
          <type>TEXT</type>
        </format>
      </return>
    </select>
    <standart_select access_mode="1" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="Роль.Список" responsible="Шаброва А.Н." type="NATIVE">
      <comment>Реализовать</comment>
      <return name="@Роль">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Примечание">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>HIERARCHY</type>
          <nodes_field>1</nodes_field>
          <hierarchy_name>Название</hierarchy_name>
        </format>
      </return>
      <return name="Скрытая">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Системная">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="ForServiceUsers">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Порядок">
        <format>
          <type>DOUBLE</type>
        </format>
      </return>
      <return name="Идентификатор">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="UserCount">
        <format>
          <type>INT64</type>
        </format>
      </return>
      <std_parameter filter_category="USER" name="ИдПользователя" param_type="OPTIONAL" type="INT64">
        <comment>можно передавать и пользователя и клиента</comment>
      </std_parameter>
      <std_parameter filter_category="USER" name="АдресСервиса" param_type="OPTIONAL" type="TEXT"/>
    </standart_select>
    <standart_select access_mode="1" is_proxy="0" is_service="0" name="Роль.СписокНаследников" type="NATIVE">
      <return name="@Роль">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Примечание">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <std_parameter filter_category="USER" name="ИдО" param_type="REQUIRED" type="TEXT"/>
    </standart_select>
    <standart_select access_mode="1" is_service="0" last_changed="Рыбаков М.А." name="Роль.СписокПользователей" responsible="Buravlevms" type="PYTHON">
      <return name="@Пользователь">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>HIERARCHY</type>
          <nodes_field>1</nodes_field>
          <hierarchy_name>Имя</hierarchy_name>
        </format>
      </return>
      <return name="Раздел@">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>clientID = Session.ClientID()
userID = Session.UserID()
show_blocked = False
if userID is None or clientID is None :
   Error( 'Не удалось определить пользователя или клиента' )

if Фильтр.Роль is None :
   Error( 'Не задан обязательный параметр \'Роль\'' )
role_id = Фильтр.Роль

if Фильтр.TestField( 'ИдПользователя' ) is not None and Фильтр.ИдПользователя is not  None :
   clientID = Фильтр.ИдПользователя
   
if Фильтр.TestField( 'ЗаблокированныеПользователи' ) is not None and Фильтр.ЗаблокированныеПользователи is not  None :
   show_blocked = Фильтр.ЗаблокированныеПользователи

queryRecursive = """WITH RECURSIVE T (
   "@Пользователь", 
   "Имя",
   "Логин",
   "Раздел", 
   "Раздел@", 
   "НаследоватьПрава", 
   "$Черновик",
   "Заблокирован"
) AS (
   SELECT 
      u."@Пользователь", 
      u."Имя",
      u."Логин",
      u."Раздел", 
      u."Раздел@", 
      u."НаследоватьПрава", 
      u."$Черновик",
      u."Заблокирован"
   FROM 
      "Пользователь" u 
   WHERE 
       u."@Пользователь" = {user}
   UNION
   SELECT 
      u."@Пользователь", u."Имя", u."Логин",
      u."Раздел", u."Раздел@", 
      u."НаследоватьПрава", 
      u."$Черновик",
      u."Заблокирован"
   FROM 
      "Пользователь" u 
   JOIN 
      T
   ON 
      u."Раздел" = T."@Пользователь"
) """.format( user = clientID )

querySelect = """ 
SELECT 
  DISTINCT T."@Пользователь", T."Имя",
      T."Раздел", T."Раздел@"
"""

queryFrom = """ 
FROM 
   T 
LEFT JOIN 
   "РолиПользователей" R
ON
   T."@Пользователь" = R."Пользователь"
WHERE 
   T."Раздел@" IS NULL 
   AND 
   T."$Черновик" IS NULL
   AND
   ( T."НаследоватьПрава" IS TRUE OR R."Название" = '{role}' )""".format( role = role_id )
   
if show_blocked is not True :
    queryFrom += """ AND T."Заблокирован" IS NOT TRUE """
    
if Фильтр.TestField( 'Имя' ) is not None and Фильтр.Имя is not None and Фильтр.Имя.__str__() :
   filter = '%' + Фильтр.Имя.__str__().lower() + '%'
   queryFrom += """ AND ( lower(T."Имя") LIKE '{fltr}' OR lower(T."Логин") LIKE '{fltr}' ) """.format( fltr = filter )

format = MethodResultFormat( "Роль.СписокПользователей", 4)
result = MethodListResult()
queryResult = queryRecursive + querySelect + queryFrom + """ ORDER BY T."Имя" """ 

if Навигация is not None and Навигация.IsNull() is False :
   page_size = Навигация.RecsOnPage()
   page_id = Навигация.Page()
   queryResult += """ LIMIT """ + str(page_size)
   if  page_id :
      queryResult += """ OFFSET """ + str(page_size * page_id)  
   queryCount = queryRecursive + """ SELECT COUNT(DISTINCT T."@Пользователь") """ + queryFrom
   rs_count = SqlQueryScalar( queryCount )
   result.nav_result = NavigationResult( rs_count ) 

rs = SqlQuery( queryResult, format )
result.cursor = rs.Cursor()
return result</body>
      </definition>
      <std_parameter filter_category="USER" name="Роль" param_type="REQUIRED" type="TEXT"/>
      <std_parameter filter_category="USER" name="Имя" param_type="OPTIONAL" type="TEXT">
        <comment>Поиск по имени или логину</comment>
      </std_parameter>
      <std_parameter filter_category="USER" name="ИдПользователя" param_type="OPTIONAL" type="INT64"/>
      <std_parameter filter_category="USER" name="ЗаблокированныеПользователи" param_type="OPTIONAL" type="BOOLEAN"/>
    </standart_select>
    <standart_select access_mode="1" is_proxy="0" is_service="0" name="Роль.СписокРодителей" type="NATIVE">
      <return name="@Роль">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Примечание">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <std_parameter filter_category="USER" name="ИдО" param_type="REQUIRED" type="TEXT"/>
    </standart_select>
    <standart_select access_mode="1" is_service="0" last_changed="Шаброва А.Н." name="Роль.СписокСГруппами" responsible="Кондратьев М.А." type="PYTHON">
      <comment>Список ролей с иерархией</comment>
      <return name="@Роль">
        <format>
          <type>OBJECT_IDENTIFIER</type>
        </format>
      </return>
      <return name="Название">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Примечание">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Раздел">
        <format>
          <type>HIERARCHY</type>
          <nodes_field>1</nodes_field>
          <hierarchy_name>Название</hierarchy_name>
        </format>
      </return>
      <return name="Скрытая">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Системная">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="ForServiceUsers">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <return name="Порядок">
        <format>
          <type>DOUBLE</type>
        </format>
      </return>
      <return name="Идентификатор">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Дир">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="UserCount">
        <format>
          <type>INT64</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>def AddFolderOnlyWithName(rec,name,res):
      rec['@Роль'].From( '-1,-1' )
      rec['Название'].From( str( name ) )
      
      res.InsRow( res.Size(), rec )
      
      
#СписокИерархия
rs = Роль.Список( ДопПоля, Фильтр, Сортировка, Навигация ) # получаем рекордсет с ролями, но без иерархии
#rs sorting
newrs = []
for item in range( len( rs ) ):
   newrs.insert( item , rs[ item ] )

indexUserRoleDir = 0
for item in range( len( newrs ) ):
   if str( newrs[ item ]['Название'] ).find('/') &gt; 0:
      rstmp = newrs[ item ]
      newrs.pop( item )
      newrs.insert( indexUserRoleDir, rstmp )
      indexUserRoleDir += 1
rs = newrs
#--------------
cache = []
HierarchyRec = Hierarchy()
recBlank = Record()
recBlank.AppendField( '@Роль', FieldType.ftIDENTIFIER, 0 )
recBlank.AppendField( 'Название', FieldType.ftTEXT, 0 )
recBlank.AddHierarchy( 'Раздел', HierarchyRec )
recBlank.AppendField( 'Примечание', FieldType.ftTEXT, 0 )
recBlank.AddBool( 'Скрытая', False )
recBlank.AddBool( 'Системная', False )
recBlank.AppendField( 'Порядок', FieldType.ftDOUBLE, 0 )
recBlank.AppendField( 'Идентификатор', FieldType.ftTEXT, 0 )
recBlank.AddInt32( 'Дир', 0 )
recBlank.AddBool( 'ForServiceUsers', False )
recBlank.AddInt64( 'UserCount', 0 )

res = RecordSet( recBlank.Format() )
i = 1                                                    # счетчик для уникальности ИД узла (папки) с ролями
systemRoleFolderCreated = 0
for item in range( len( rs ) ):
   roleID = 0                                            # нужен для записи последнего ИД узла в ветки
   roleLastName = ''                                     # имя последней или корневой директории
   dirPath = ''                                          # нужен для пошагового накопления пути директории
   dirLevel = 0
   exp = str( rs[ item ]['Название'] ).split( '/' , 1 )      # разделение строки и выделение папок дир1/дир2/дир3/лист
   # цикл - парсер директорий
   for e in range( 0, len( exp ) -1):                    # проходим по списку выделенных директорий дир1 , дир2 , дир3 - если он не пустой (-1 не берем лист)
      strExpE = str( exp[ e ] )                          # название директории из списка
      dirPath += strExpE + '/'                           # накапливаем путь от корня до текущей директории


      id = 0                                             # ИД директории и флаг - заполняется, если найден в кэше директорий

      for cacheItem in cache:                            # поиск в кеше по пути к текущей директории
         if cacheItem ['dirPath'] == dirPath:            # нашлось!!! тогда заполняем данные id, parID и parName
            id = cacheItem ['id']
            break
      if id:                                             # поиск в кеше был удачным и новая запись о директории в выходной рекордсет не добавляется
         roleID = id                                     # запоминается ИД для дальнейшей итерации поиска директории или для конечного узла роли
         roleLastName = strExpE                          # название текущей директории - такоеже как и в кеше.
         dirLevel += 1
      else:                                              # ничего не нашлось в кеше - создаём новую запись о директории в выходной рекордсет
         cache.append( {'id': i, 'dirPath': dirPath ,'parID': roleID, 'parName': roleLastName} ) # добавляем в кеш инфо о новой директории
         HierarchyRec = Hierarchy()
         HierarchyRec.Parent = ObjectId()
         HierarchyRec.Branch = BranchType.LEAF           # LEAF , NODE , HIDDEN - в данном случае директория это узел ( папка )
         HierarchyRec.HasChild = True                    # у директории есть дети

         rec = Record()
         rec.AppendField( '@Роль', FieldType.ftIDENTIFIER, 0 )
         #rec['@Роль'].From( str( i ) + ',' + strExpE ) # заполняем уникальный ИД роли и её название - это сложный ИД!
         rec['@Роль'].From( str( i ) + ',' + '-1' ) # заполняем уникальный ИД роли и её название - это сложный ИД!
         rec.AppendField( 'Название', FieldType.ftTEXT, 0 )
         rec['Название'].From( strExpE )                 # название текущей директории
         rec.AddHierarchy( 'Раздел', HierarchyRec )
         rec.AppendField( 'Примечание', FieldType.ftTEXT, 0 )
         rec.AddBool( 'Скрытая', False )
         rec.AddBool( 'Системная', False )
         rec.AppendField( 'Порядок', FieldType.ftDOUBLE, 0 )
         rec.AppendField( 'Идентификатор', FieldType.ftTEXT, 0 )
         rec.AddInt32( 'Дир', int( dirLevel ) )
         rec.AddBool( 'ForServiceUsers', False )
         rec.AddInt64( 'UserCount', 0 )

         dirLevel += 1
         res.InsRow( res.Size(), rec )                          # добавление следующей строки в рекордсет

         roleID = i                                      # текущее значение ИД
         roleLastName = strExpE                          # текущее название директории
         i += 1

   #заполнение данных о листе
   HierarchyRec = Hierarchy()
   rec = Record()
   rec.AppendField( '@Роль', FieldType.ftIDENTIFIER, 0 )
   rec['@Роль'].From( str( rs[ item ]['@Роль'] ) )       # заполняем уникальный ИД роли и её название - это сложный ИД!
   rec.AppendField( 'Название', FieldType.ftTEXT, 0 )
   rec['Название'].From( str( exp[ -1 ] ) )              # название текущей директории
   rec.AddHierarchy( 'Раздел', HierarchyRec )

   if roleID == 0:
      if systemRoleFolderCreated == 0 and indexUserRoleDir != 0:
         AddFolderOnlyWithName(recBlank,'Прочие роли',res)
         systemRoleFolderCreated = 1

      dirLevel +=1

   rec.AppendField( 'Примечание', FieldType.ftTEXT, 0 )
   rec['Примечание'].From( str( rs[ item ]['Примечание'] ) )
   rec.AddBool( 'Скрытая')
   rec['Скрытая'].From( rs[ item ]['Скрытая'] )
   rec.AddBool( 'Системная')
   rec['Системная'].From( rs[ item ]['Системная'] )
   rec.AppendField( 'Порядок', FieldType.ftDOUBLE, 0 )
   rec['Порядок'].From( float( rs[ item ]['Порядок'] ) )
   rec.AppendField( 'Идентификатор', FieldType.ftTEXT, 0 )
   rec['Идентификатор'].From( str( rs[ item ]['Идентификатор'] ) )
   rec.AddInt32( 'Дир', int( dirLevel ) )
   rec.AddBool( 'ForServiceUsers')
   rec['ForServiceUsers'].From( rs[ item ]['ForServiceUsers'] )
   rec.AddInt64( 'UserCount')
   rec['UserCount'].From( rs[ item ]['UserCount'] )
   res.InsRow( res.Size(), rec )                          # добавление следующей строки в рекордсет
#----------------------------------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------------------------------
#----------------------------------------------------------------------------------------------------------------------------
mlr= MethodListResult()
mlr.cursor = res.Cursor()
mlr.nav_result = NavigationResult( res.Size() )
return mlr                                            # вернули рекордсет с иерархией</body>
      </definition>
      <std_parameter filter_category="USER" name="ИдПользователя" param_type="OPTIONAL" type="INT64">
        <comment>можно передавать и пользователя и клиента</comment>
      </std_parameter>
      <std_parameter filter_category="USER" name="АдресСервиса" param_type="OPTIONAL" type="TEXT"/>
    </standart_select>
    <select access_mode="0" is_proxy="0" is_service="0" last_changed="Шаброва А.Н." name="Роль.Удалить" responsible="Шаброва А.Н." returns="SCALAR" type="NATIVE">
      <parameter name="ИдО">
        <format>
          <type>TEXT[]</type>
        </format>
      </parameter>
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
    </select>
  </object>

</repository>
