<?xml version="1.0" encoding="WINDOWS-1251"?>
<repository orx_version="1.71">

  <object last_changed="Ткачук М.И." name="История" responsible="Ткачук М.И.">
    <select access_mode="0" is_service="0" last_changed="Мирзоян Г.Ю." name="История.ЕстьСотрудник" responsible="Буравлев М.С." returns="SCALAR" type="PYTHON">
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>BOOLEAN</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return hasattr( Пользователь, 'СвязьПользователя' )</body>
      </definition>
    </select>
    <select access_mode="0" is_service="1" last_changed="Желдокас С.А." name="История.ЗарегистрироватьКонтекст" responsible="Ткачук М.И." returns="SCALAR" type="PYTHON">
      <return name="___SBIS_SCALAR_RETURN___">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>filter = lambda param, field, quote: str( field + " = "  + quote + str( param ) + quote ) if param is not None else str( field + " is null " )
# Получить контекст исполнения
_uid = Session.UserID()
_ipe = Session.ExternalIP() or "::1"
_ipi = Session.InternalIP()
if _ipi == "0.0.0.0":
   _ipi = None
_subj = Session.Get(WebServerContextKey.icsX_SUBJECT) or ""
_session = Session.ID() or ""
query = """ select "@$Пользователь" from "log.$Пользователь" 
   where """ + filter( _uid, """ "Пользователь" """, "" ) + " and " + filter( _ipe, """ "IP" """, "'" ) + " and " + filter( _ipi, """ "IPВнутренний" """, "'" ) + " and " + filter( _subj, """ "Субъект" """, "'" ) + " and " + filter( _session, """ "Сессия" """, "'" ) + " limit 1"
logUserId = SqlQueryScalar( query )
if logUserId is None:
   rs = SqlQuery( """insert into "log.$Пользователь" values(default) returning "@$Пользователь" as log_user_id""" )
   logUserId = rs[0].log_user_id

check = SqlQueryScalar( """ SELECT EXISTS ( SELECT 1 FROM "log.$Изменение" WHERE "Транзакция" = txid_current() AND "Предок" = $1 ) """,logUserId )
if check:
   rs = SqlQuery( """insert into "log.$Изменение"( "Таблица" ) values( '"ИсторияПользовательскоеСобытие"'::regclass ) returning "@$Изменение" as changing_id""" )
else:
   rs = SqlQuery( """insert into "log.$Изменение"( "Таблица", "Предок" ) values( '"ИсторияПользовательскоеСобытие"'::regclass, {parent_id} ) returning "@$Изменение" as changing_id""".format( parent_id = logUserId ) )

return rs[0].changing_id

</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.ЗарегистрироватьСобытие" responsible="Ткачук М.И." returns="NONE" type="PYTHON">
      <parameter name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>if ( Сообщение and Действие ) is None:
   raise ValueError( 'Параметры метода регистрации события истории должны быть заполнены!' )
with CreateTransaction( TransactionLevel.READ_COMMITTED, TransactionMode.WRITE ):
   message = Сообщение
   eventName = Действие.lower()
   # Получить ID из таблица ИсторияДействие
   eventId = SqlQueryScalar( """select "@ИсторияДействие" from "ИсторияДействие" where "Действие" = $1 """, eventName )
   # Если действие не зарегистрировано, то добавляем и возвращаем ID
   if eventId is None:
      rs = SqlQuery( """insert into "ИсторияДействие"( "Действие" ) values( $1 ) returning "@ИсторияДействие" as event_id""", eventName )
      eventId = rs[0].event_id
   # Получить контекст исполнения
   context_id = История.ЗарегистрироватьКонтекст()
   # Зарегистрировать событие
   SqlQuery( """insert into "ИсторияПользовательскоеСобытие"( "Сообщение", "Действие", "КонтекстИсполнения", "Когда" ) 
      values( $1, $2, $3, current_timestamp )""", message, eventId, context_id )</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.ЗарегистрироватьСобытие" responsible="Ткачук М.И." returns="NONE" type="PYTHON">
      <parameter name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="Объект">
        <format>
          <type>TEXT</type>
        </format>
      </parameter>
      <parameter name="ИдентификаторОбъекта">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <definition>
        <language>PYTHON</language>
        <body>if ( Сообщение and Действие and Объект and ИдентификаторОбъекта) is None:
   raise ValueError( 'Параметры метода регистрации события истории должны быть заполнены!' )
with CreateTransaction( TransactionLevel.READ_COMMITTED, TransactionMode.WRITE ):
   message = Сообщение
   eventName = Действие.lower()
   objectName = Объект.lower()

   # Получить ID из таблица ИсторияДействие
   eventId = SqlQueryScalar( """select "@ИсторияДействие" from "ИсторияДействие" where "Действие" = $1 """, eventName )

   # Если действие не зарегистрировано, то добавляем и возвращаем ID
   if eventId is None:
      rs = SqlQuery( """insert into "ИсторияДействие"( "Действие" ) values( $1 ) returning "@ИсторияДействие" as event_id""", eventName )
      eventId = rs[0].event_id

   # Получить контекст исполнения
   context = История.ЗарегистрироватьКонтекст()

   # Получаем/регистрируем объект
   # Получить ID из таблица ИсторияДействие
   objectId = SqlQueryScalar( """select "@ИсторияОбъект" from "ИсторияОбъект" where "Объект" = $1 """, objectName )

   # Если действие не зарегистрировано, то добавляем и возвращаем ID
   if objectId is None:
      rs = SqlQuery( """insert into "ИсторияОбъект"( "Объект" ) values( $1 ) returning "@ИсторияОбъект" as object_id""", objectName )
      objectId = rs[0].object_id

   # Зарегистрировать событие
   SqlQuery( """insert into "ИсторияПользовательскоеСобытие"( "Сообщение", "Действие", "КонтекстИсполнения", "Когда", "Объект", "ИдентификаторОбъекта" ) 
      values( $1, $2, $3, current_timestamp, $4, $5 )""", message, eventId, context, objectId, ИдентификаторОбъекта or -1 )</body>
      </definition>
    </select>
    <select access_mode="0" is_service="0" last_changed="Буравлев М.С." name="История.Контекст" responsible="Буравлев М.С." returns="TABLE" type="SQL">
      <parameter name="Контекст">
        <format>
          <type>INTEGER</type>
        </format>
      </parameter>
      <return name="Пользователь">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Субъект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="IP">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="IPВнутренний">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="РабочееМесто">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PLPGSQL</language>
        <body>select
	"Пользователь",
	"Субъект",
	host( "IP" ) as "IP",
	host( "IPВнутренний" ) as "IPВнутренний",
	"ИмяХоста" as "РабочееМесто"
from
	"log.$Пользователь"
where
	"@$Пользователь" = :Контекст</body>
      </definition>
    </select>
    <standart_select access_mode="0" is_proxy="0" is_service="0" last_changed="Желдокас С.А." name="История.Список" responsible="Буравлев М.С." type="NATIVE">
      <return name="РеальноеВремя">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="Время">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Объект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Пользователь">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Контекст">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <std_parameter filter_category="USER" name="ТолькоИзмененные" param_type="OPTIONAL" type="BOOLEAN"/>
      <std_parameter filter_category="USER" name="ИдО" param_type="REQUIRED" type="INT64"/>
      <std_parameter filter_category="USER" name="ВремяОт" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="ВремяДо" param_type="OPTIONAL" type="TEXT"/>
    </standart_select>
    <standart_select access_mode="0" is_service="1" last_changed="Ткачук М.И." name="История.СписокДействий" responsible="Ткачук М.И." type="PYTHON">
      <return name="ИдентификаторДействия">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return SqlQuery( """select "@ИсторияДействие" as "ИдентификаторДействия", "Действие" as "Действие" from "ИсторияДействие" """)</body>
      </definition>
    </standart_select>
    <standart_select access_mode="0" is_service="1" last_changed="Ткачук М.И." name="История.СписокОбъектов" responsible="Ткачук М.И." type="PYTHON">
      <return name="ИдентификаторОбъекта">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Объект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>return SqlQuery( """select "@ИсторияОбъект" as "ИдентификаторОбъекта", "Объект" as "Объект" from "ИсторияОбъект" """)</body>
      </definition>
    </standart_select>
    <standart_select access_mode="0" is_service="0" last_changed="Желдокас С.А." name="История.СписокПроизвольнойИстории" responsible="Ткачук М.И." type="PYTHON">
      <return name="Время">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Объект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="ИдентификаторОбъекта">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Логин">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Пользователя">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="КонтекстИсполнения">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <return name="Субъект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Транзакция">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body># Функция проверки задан фильтр или нет
# -------------------------------------
def TestFilter( filter, filterName ):
   if filter is not None and filter.TestField( filterName ) is not None and not filter[filterName].IsNull() and str( filter[filterName] ).strip() != "":
      return True
   return False
# Функция формирования условия where
# -------------------------------------
def MakeWhereClause( first, filter, query):
   if first:
      first = False
      query += """ where """ + filter
   else:
      query += """ and """ + filter
   return first, query
# Функция формирования параметра сортировки
# -------------------------------------
def MakeSortClause( query, sortParam ):
   if sortParam.fieldName == "Когда" or sortParam.fieldName == "Время":
      query += """ "Время" """
   if sortParam.order == SortOrder.soASCENDING:
      query += " asc "
   if sortParam.order == SortOrder.soDESCENDING:
      query += " desc "
   return query
# Тело выборки
# -------------------------------------
queryFields = """
select user_event."Когда" as "Время", 
   user_event."Сообщение" as "Сообщение", 
   event."Действие" as "Действие", 
   object."Объект" as "Объект", 
   user_event."ИдентификаторОбъекта" as "ИдентификаторОбъекта", 
   user_."Логин" as "Логин", 
   user_."@Пользователь" as "Пользователь", 
   user_."Имя" as "Имя", 
   log_user."@$Пользователь" as "КонтекстИсполнения",
   log_changing."Транзакция" as "Транзакция" """ 
queryTables = """ from "ИсторияПользовательскоеСобытие" user_event 
      join "ИсторияДействие" event on user_event."Действие" = event."@ИсторияДействие"       
      join "log.$Изменение" log_changing on user_event."КонтекстИсполнения" = log_changing."@$Изменение"  
      left join "log.$Пользователь" log_user on log_changing."Предок" = log_user."@$Пользователь"
      left join "Пользователь" user_ on log_user."Пользователь" = user_."@Пользователь"
      left join "ИсторияОбъект" object on user_event."Объект" = object."@ИсторияОбъект" """
# Фильтры
# -------------------------------------
filter = Фильтр
first = True
queryWhere = ""
if TestFilter( filter, 'ВремяОт' ):
   filterText = """ user_event."Когда" &gt;= '{date_begin_param}' """.format( date_begin_param = filter['ВремяОт'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'ВремяДо' ):
   filterText = """ user_event."Когда" &lt;= '{date_end_param}' """.format( date_end_param = filter['ВремяДо'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'КонтекстИсполнения' ):
   filterText = """ user_event."КонтекстИсполнения" = {context_param} """.format( context_param = filter['КонтекстИсполнения'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Объект' ):
   filterText = """ object."Объект" = '{object_param}' """.format( object_param = str( filter['Объект'] ).lower() )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Действие' ):
   filterText = """ event."Действие" = '{event_param}' """.format( event_param = str( filter['Действие'] ).lower() )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Субъект' ):
   filterText = """ log_user."Субъект" = '{subject_param}' """.format( subject_param = filter['Субъект'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Сессия' ):
   filterText = """ log_user."Сессия" = '{session_param}' """.format( session_param = filter['Сессия'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Пользователь' ):
   filterText = """ log_user."Пользователь" = {user_param} """.format( user_param = filter['Пользователь'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )
   
if TestFilter( filter, 'Логин' ):
   filterText = """ user_."Логин" = '{user_login_param}' """.format( user_login_param = filter['Логин'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )
   
if TestFilter( filter, 'Имя' ):
   filterText = """ user_."Имя" = '{user_name_param}' """.format( user_name_param = filter['Имя'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Транзакция' ):
   filterText = """ log_changing."Транзакция" = {trans_param} """.format( trans_param = filter['Транзакция'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )
   
if TestFilter( filter, 'ИдентификаторОбъекта' ):
   filterText = """ user_event."ИдентификаторОбъекта" = {object_id_param} """.format( object_id_param = filter['ИдентификаторОбъекта'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

if TestFilter( filter, 'Сообщение' ):
   filterText = """ user_event."Сообщение" ilike '%{message_param}%' """.format( message_param = filter['Сообщение'] )
   first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

# Обработка параметров сортировки
# -------------------------------------
sort = Сортировка
querySort = ""
if sort and sort.size():
   querySort += " order by "
   for param in sort:
      querySort = MakeSortClause( querySort, param )
else:
   querySort += """ order by "Время" desc"""

# Выполнение запроса и формирование результата
# -------------------------------------
nav = Навигация
result = MethodListResult()
query = queryFields + queryTables + queryWhere + querySort
if not nav.IsNull():
   # Постраничная навигация по методу Есть ли еще
   if nav.IsNext():
      if nav.Page() &gt;= 0:
         query += """ offset """ + str ( nav.Page() * nav.RecsOnPage() )
         query += """ limit """ + str( nav.RecsOnPage() + 1 )

   # При переходе на последнюю страницу рассчитывается количество всех записей
   if not nav.IsNext() and nav.Page() == -1:
      queryCount = "select count(*) " + queryTables + queryWhere
      recordsCount = SqlQueryScalar( queryCount )
      result.nav_result = NavigationResult( recordsCount )
      offset = int( recordsCount / nav.RecsOnPage() )
      query += """ offset """ + str ( offset * nav.RecsOnPage() )
      query += """ limit """ + str( nav.RecsOnPage() )

   # Постраничная навигация с подсчетом результирующего числа записей
   if not nav.IsNext() and nav.Page() &gt;= 0:
      queryCount = queryCount = "select count(*) " + queryTables + queryWhere
      recordsCount = SqlQueryScalar( queryCount )
      result.nav_result = NavigationResult( recordsCount )
      query += """ offset """ + str ( nav.Page() * nav.RecsOnPage() )
      query += """ limit """ + str( nav.RecsOnPage() )

# Выполнение запроса
resultData = SqlQuery( query )

transaction_and_name = dict()
transaction = list()
for rec in resultData:
   if not rec.Имя:
      transaction.append( rec.Транзакция )
      transaction_and_name[ rec.Транзакция ] = 'Не определено'

query_name = """
               SELECT
                  log_changing."Транзакция" AS "Транзакция",
                  user_."Имя" AS "Имя"
               FROM
                  "log.$Изменение" log_changing
               LEFT JOIN
                  "log.$Пользователь" log_user
                           ON
                              log_changing."Предок" = log_user."@$Пользователь"
               LEFT JOIN
                  "Пользователь" user_
                           ON
                              log_user."Пользователь" = user_."@Пользователь"
               WHERE
                  log_changing."Транзакция" = ANY( '{array_transaction}'::bigint[] ) """.format( array_transaction = '{' + ",".join(str(v) for v in transaction) + '}' )
result_query_name = SqlQuery( query_name )

for rec in result_query_name:
   if rec.Имя:
      transaction_and_name[ rec.Транзакция ] = rec.Имя

for rec_ in resultData:
   if not rec_.Имя:
      rec_.Имя = transaction_and_name[ rec_.Транзакция ]


# Постраничная навигация по методу Есть ли еще. Удаляем из результирующего набора лишнюю одну строку
if not nav.IsNull() and nav.IsNext():
   if resultData.Size() &gt; nav.RecsOnPage():
      result.nav_result = NavigationResult( True )
      resultData.DelRow( nav.RecsOnPage() )
   else:
      result.nav_result = NavigationResult( False )

result.cursor = resultData.Cursor()
return result</body>
      </definition>
      <std_parameter filter_category="USER" name="Транзакция" param_type="OPTIONAL" type="INTEGER"/>
      <std_parameter filter_category="USER" name="Субъект" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="Сообщение" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="Сессия" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="Объект" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="Логин" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="КонтекстИсполнения" param_type="OPTIONAL" type="INTEGER"/>
      <std_parameter filter_category="USER" name="Имя" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="ИдентификаторПользователя" param_type="OPTIONAL" type="INTEGER"/>
      <std_parameter filter_category="USER" name="ИдентификаторОбъекта" param_type="OPTIONAL" type="INTEGER"/>
      <std_parameter filter_category="USER" name="Действие" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="ВремяОт" param_type="OPTIONAL" type="DATETIME"/>
      <std_parameter filter_category="USER" name="ВремяДо" param_type="OPTIONAL" type="DATETIME"/>
    </standart_select>
    <standart_select access_mode="0" is_service="0" last_changed="Буравлев М.С." name="История.СписокСлужебный" responsible="Желдокас С.А." type="PYTHON">
      <return name="РеальноеВремя">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="Время">
        <format>
          <type>DATETIME</type>
        </format>
      </return>
      <return name="Сообщение">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Действие">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Объект">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Пользователь">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Имя">
        <format>
          <type>TEXT</type>
        </format>
      </return>
      <return name="Контекст">
        <format>
          <type>INTEGER</type>
        </format>
      </return>
      <definition>
        <language>PYTHON</language>
        <body>from historygetter import HistoryGetter
import re

def СписокСлужебныйАвтогенерируемойИстории( ДопПоля, Фильтр, Сортировка, Навигация ):

   frmt = MethodResultFormat('История.Список', 4)
   res = CreateRecordSet(frmt)
   recRes = Record(frmt)

   filter_for_change = Record()
   filter_for_change.AddArrayInt32("ИдСобытияСписок")
   filter_for_change.AddBool( "ТолькоНазванияПолей" )
   filter_for_change.AddBool( "ТолькоИзмененныеПоля" )
   #filter_for_change.ТолькоНазванияПолей = False
   filter_for_change.ТолькоИзмененныеПоля = Фильтр.ТолькоИзмененныеПоля if 'ТолькоИзмененныеПоля' in Фильтр else True

   transaction = 0
   history = HistoryGetter(Фильтр, Навигация)
   captions = history.get_history_headers()
   transactions_and_it_changes = dict()
   table_and_it_changes = dict()
   changes_by_table_in_transaction = dict()
   event_rs_by_transaction = dict()
   user_history_handler = Фильтр.ПользовательскийОбработчик

   if user_history_handler:
      user_history_handler = user_history_handler.replace('\n','\n   ')
      code = '''def fun( События ):\n   import historygetter\n   {code}\nout_ = fun( in_ )'''.format( code=user_history_handler )
      user_handler = compile( code, 'historyHandler', 'exec' )
   else:
      user_handler = None

   ### handle_transaction ##################################################################################################
   def handle_transaction( transaction_, transaction_details ):
      context = None

      for table_, table_info in transaction_details.items():
         if not context:
            context = table_info['context']
            break

      changes_in_transaction = event_rs_by_transaction[ transaction_ ]

      #Если присуствутет пользовательский метод обработки
      if user_history_handler:
         #ПользовательскоеПредставлениеТаблицыРолиПользователей( changes_in_transaction )
         locals_ = { 'in_' : changes_in_transaction }
         exec( user_handler, dict( globals() ), locals_ )

      first_record = True
      message = ''
      #Занести изменения в результирующий список записей
      if changes_in_transaction is not None:
         changes_in_transaction.SortRows(lambda rec_a, rec_b: ( rec_a.id and rec_a.id &gt; rec_b.id ) )
         for change in changes_in_transaction:
            if not first_record:
               message += '\r\n'

            message += HistoryGetter.get_message_by_data( change ) if not change.Сообщение else change.Сообщение
            message += '.'
            
            if first_record:
               recRes.Время = context.Время.replace( second=0, microsecond=0 )
               recRes.РеальноеВремя = context.Время
               recRes.Объект = context.Объект
               recRes.Пользователь = context.Пользователь
               recRes.Контекст = context.Контекст
               recRes.Имя = context.Имя
               recRes.Действие = change.Действие
               first_record = False

         if ( ( 'Сообщение' not in Фильтр or not Фильтр.Сообщение ) or re.search( Фильтр.Сообщение, message, re.I ) ) and changes_in_transaction.Size():
            recRes.Сообщение = message
            res.AddRow(recRes)
      #~newContext
   #~handle_transaction#################################################################################################

   for caption in captions:
      #чтобы первоначальную транзакцию инициализировать
      if transaction == 0:
         transaction = caption.Транзакция

      #определяем сменилась ли транзакция
      newContext = caption.Транзакция != transaction

      old_transaction = transaction
      #запоминаем транзакцию
      transaction = caption.Транзакция

      if newContext: #здесь вычисляем все записи, подобавляем и тд
         transactions_and_it_changes[ old_transaction ] = changes_by_table_in_transaction.copy()
         changes_by_table_in_transaction.clear()

      if caption.Таблица in changes_by_table_in_transaction:
         changes_by_table_in_transaction[caption.Таблица]['changes'].append( caption.id )
         #changes_by_table_in_transaction[caption.Таблица]['action'] = HistoryGetter.get_mixed_action( changes_by_table_in_transaction[caption.Таблица]['action'], caption.Действие )
      else:
         changes_by_table_in_transaction[caption.Таблица] = {
            'changes': [caption.id],
            'context': caption
            #'action': caption.Действие
         }

      if caption.Таблица in table_and_it_changes:
         table_and_it_changes[ caption.Таблица ].append( caption.id )
      else:
         table_and_it_changes[ caption.Таблица ] = [caption.id]

   transactions_and_it_changes[ transaction ] = changes_by_table_in_transaction.copy()
   changes_by_table_in_transaction.clear()

   rs_format = None

   for table, changes in table_and_it_changes.items():
      filter_for_change.ИдСобытияСписок = changes
      detailed_changes = HistoryGetter( filter_for_change )
      events_by_table = detailed_changes.get_events( table )

      for event in events_by_table:
         if not rs_format:
            rs_format = event.Format()

         tr = event.Транзакция
         if tr not in event_rs_by_transaction:
            event_rs_by_transaction[ tr ] = CreateRecordSet( rs_format )

         event_rs_by_transaction[ tr ].AddRow( event )

   for transaction, changes in transactions_and_it_changes.items():
      if transaction not in event_rs_by_transaction:
         continue
      handle_transaction( transaction, changes )

   return res
######################################################################################################################################################################################

def СписокСлужебныйПроизвольнойИстории( ДопПоля, Фильтр, Сортировка, Навигация ):
   # Функция проверки задан фильтр или нет
   # -------------------------------------
   def TestFilter( filter, filterName ):
      if filter is not None and filter.TestField( filterName ) is not None and not filter[filterName].IsNull() and str( filter[filterName] ).strip() != "":
         return True
      return False
   # Функция формирования условия where
   # -------------------------------------
   def MakeWhereClause( first, filter, query):
      if first:
         first = False
         query += """ where """ + filter
      else:
         query += """ and """ + filter
      return first, query
   # Функция формирования параметра сортировки
   # -------------------------------------
   def MakeSortClause( query, sortParam ):
      if sortParam.fieldName == "Когда" or sortParam.fieldName == "Время":
         query += """ "РеальноеВремя" """
      if sortParam.order == SortOrder.soASCENDING:
         query += " ASC "
      if sortParam.order == SortOrder.soDESCENDING:
         query += " DESC "
      return query

   # Получаем адрес сервиса с которого зашли
   # -------------------------------------
   site = ConfigGet( 'АдресСервиса' ).lower()
   site = site[ site.find( '://' ) + 3 : ]
   # Тело выборки
   # -------------------------------------
   queryFields = """
      SELECT
         user_event."Когда" AS "РеальноеВремя",
         NULL::timestamp AS "Время",
         user_event."Сообщение" AS "Сообщение",
         event."Действие" AS "Действие",
         object."Объект" AS "Объект",
      CASE WHEN SUBSTRING( log_user."Субъект" FROM '#.+' ) = '#{site}'
         THEN
            log_user."Субъект"
         ELSE
            log_user."Пользователь"::text
      END AS "Пользователь",
      user_."Имя" AS "Имя",
         log_user."@$Пользователь" AS "Контекст",
         log_changing."Транзакция" AS "Транзакция" """.format( site = site )

   queryTables = """
      FROM
         "ИсторияПользовательскоеСобытие" user_event
      JOIN
         "ИсторияДействие" event
      ON
         user_event."Действие" = event."@ИсторияДействие"
      JOIN
         "log.$Изменение" log_changing
      ON
         user_event."КонтекстИсполнения" = log_changing."@$Изменение"
      LEFT JOIN
         "log.$Пользователь" log_user
      ON
         log_changing."Предок" = log_user."@$Пользователь"
      LEFT JOIN
         "Пользователь" user_
      ON
         log_user."Пользователь" = user_."@Пользователь"
      LEFT JOIN
         "ИсторияОбъект" object
      ON
         user_event."Объект" = object."@ИсторияОбъект" """
   # Фильтры
   # -------------------------------------
   filter = Фильтр
   first = True
   queryWhere = ""
   if TestFilter( filter, 'ВремяОт' ):
      filterText = """ user_event."Когда" &gt; '{date_begin_param}' """.format( date_begin_param = filter['ВремяОт'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'ВремяОтсчета' ):
      filterText = """ user_event."Когда" &lt;= '{date_end_param}' """.format( date_end_param = filter['ВремяОтсчета'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )
   elif TestFilter( filter, 'ВремяДо' ):
      filterText = """ user_event."Когда" &lt;= '{date_end_param}' """.format( date_end_param = filter['ВремяДо'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'КонтекстИсполнения' ):
      filterText = """ user_event."КонтекстИсполнения" = {context_param} """.format( context_param = filter['КонтекстИсполнения'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Объект' ):
      filterText = """ object."Объект" = '{object_param}' """.format( object_param = str( filter['Объект'] ).lower() )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'ИдО' ):
      filterText = """ user_event."ИдентификаторОбъекта" = '{object_param}' """.format( object_param = str( filter['ИдО'] ).lower() )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Действие' ):
      filterText = """ event."Действие" = '{event_param}' """.format( event_param = str( filter['Действие'] ).lower() )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Субъект' ):
      filterText = """ log_user."Субъект" = '{subject_param}' """.format( subject_param = filter['Субъект'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Сессия' ):
      filterText = """ log_user."Сессия" = '{session_param}' """.format( session_param = filter['Сессия'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Пользователь' ):
      filterText = ( """ "Субъект" = '""" + str( filter['Пользователь'] ) + "'"  ) if '#' in str( filter['Пользователь'] ) else ( """ "Пользователь" = """ + str( filter['Пользователь'] ) )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Имя' ):
      filterText = """ user_."Имя" = '{user_name_param}' """.format( user_name_param = filter['Имя'] )
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   if TestFilter( filter, 'Сообщение' ):
      filterText = """ user_event."Сообщение" ILIKE '%$1%' """
      first, queryWhere = MakeWhereClause( first, filterText, queryWhere )

   # Обработка параметров сортировки
   # -------------------------------------
   sort = Сортировка
   querySort = ""
   if sort and sort.size():
      querySort += " ORDER BY "
      for param in sort:
         querySort = MakeSortClause( querySort, param )
   else:
      querySort += """ ORDER BY "РеальноеВремя" DESC"""

   # Выполнение запроса и формирование результата
   # -------------------------------------
   nav = Навигация
   query = queryFields + queryTables + queryWhere + querySort
   query += """ limit """ + str( nav.RecsOnPage() + 1 )

   # Выполнение запроса
   if TestFilter( filter, 'Сообщение' ):
      resultData = SqlQuery( query, filter.Сообщение )
   else:
      resultData = SqlQuery( query )

   transaction_and_name = dict()
   transaction = list()
   for rec in resultData:
      if not rec.Имя:
         transaction.append( rec.Транзакция )
         transaction_and_name[ rec.Транзакция ] = 'Не определено'
   
   query_name = """
                  SELECT
                     log_changing."Транзакция" AS "Транзакция",
                     user_."Имя" AS "Имя"
                  FROM
                     "log.$Изменение" log_changing
                  LEFT JOIN
                     "log.$Пользователь" log_user
                              ON
                                 log_changing."Предок" = log_user."@$Пользователь"
                  LEFT JOIN
                     "Пользователь" user_
                              ON
                                 log_user."Пользователь" = user_."@Пользователь"
                  WHERE
                     log_changing."Транзакция" = ANY( '{array_transaction}'::bigint[] ) """.format( array_transaction = '{' + ",".join(str(v) for v in transaction) + '}' )
   result_query_name = SqlQuery( query_name )
   
   for rec in result_query_name:
      if rec.Имя:
         transaction_and_name[ rec.Транзакция ] = rec.Имя

   # Инициализируем поле "Время"
   for rec in resultData:
      rec.Время = rec.РеальноеВремя.replace( second=0, microsecond=0 )
      if not rec.Имя:
         rec.Имя = transaction_and_name[ rec.Транзакция ]

   return resultData
##############################################################################################################################################################################

def result_handler( result ):
   navi = False
   if result:
      # получаем метод сортировки получившейся таблицы
      sort = Сортировка
      if sort and sort.size():
         for sortParam in sort:
            if sortParam.fieldName == "Когда" or sortParam.fieldName == "Время":
               if sortParam.order == SortOrder.soASCENDING:
                  result.SortRows( lambda rec_a, rec_b: rec_a.РеальноеВремя &gt; rec_b.РеальноеВремя )## сортируем по времени результирующую таблицу по возрастанию
               else:
                  result.SortRows( lambda rec_a, rec_b: rec_a.РеальноеВремя &lt; rec_b.РеальноеВремя )## сортируем по времени результирующую таблицу по убыванию
      else:
         result.SortRows( lambda rec_a, rec_b: rec_a.РеальноеВремя &gt; rec_b.РеальноеВремя )
      nav = Навигация
      if not nav.IsNull() and ( result.Size() - nav.RecsOnPage() ) &gt; 0 :
         navi = True
         indexForDel = range( nav.RecsOnPage(), result.Size() )
         # удаляем ненужные записи, оставляя выборку запрашиваемой длинны
         for i in reversed( indexForDel ):
            result.DelRow( i )
   mlr = MethodListResult()
   mlr.cursor = result.Cursor()
   mlr.nav_result = NavigationResult( navi )
   return mlr
#################################################################################################################################################################################

# удаляем из строки фильтра лидирующие
if Фильтр.TestField( 'Сообщение' ) is not None and not Фильтр['Сообщение'].IsNull() and Фильтр.Сообщение.strip() != "":
   Фильтр.Сообщение = re.escape( Фильтр.Сообщение )

# слияние двух таблиц с равным форматом
autoHistory = СписокСлужебныйАвтогенерируемойИстории( ДопПоля, Фильтр, Сортировка, Навигация )
artHistory = СписокСлужебныйПроизвольнойИстории( ДопПоля, Фильтр, Сортировка, Навигация )

if autoHistory.Size():
   if artHistory.Size():
      for rec in artHistory:
         autoHistory.AddRow( rec )
   return result_handler( autoHistory )
else:
   return result_handler( artHistory )</body>
      </definition>
      <std_parameter filter_category="USER" name="ТолькоИзмененные" param_type="OPTIONAL" type="BOOLEAN"/>
      <std_parameter filter_category="USER" name="ИдО" param_type="REQUIRED" type="INT64"/>
      <std_parameter filter_category="USER" name="ВремяОт" param_type="OPTIONAL" type="TEXT"/>
      <std_parameter filter_category="USER" name="ВремяДо" param_type="OPTIONAL" type="TEXT"/>
    </standart_select>
  </object>

</repository>
