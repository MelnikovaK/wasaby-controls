<?xml version="1.0" encoding="WINDOWS-1251"?>
<converter_library version="1.02">

  <converter abstract="0" call_once="1" for_new_db="0" last_changed="Ткачук М.И." name="ИмяХоста" responsible="Ткачук М.И.">
    <rule name=".*" schema="public" stage="0" type="0"/>
    <callback event="1">
      <body>declare host_name_field text := null;
begin
   if context-&gt;'schema' &lt;&gt; 'public' then
      return;
   end if;
-- Проверка поля ИмяХоста
   select at.attname
   from pg_attribute at inner join pg_type tp on at.atttypid = tp.oid 
   where at.attrelid = 'public."log.$Пользователь"'::regclass and at.attnum &gt; 0 and not at.attisdropped and at.attname = 'ИмяХоста' into host_name_field;
   if (host_name_field is null) then
      alter table "log.$Пользователь" add column "ИмяХоста" 
         text;
   end if;
end</body>
    </callback>
  </converter>

  <converter abstract="0" call_once="1" for_new_db="1" last_changed="Ткачук М.И." name="ИндексНаИмяХоста" responsible="Ткачук М.И.">
    <rule name=".*" schema="public" stage="1" type="0"/>
    <callback event="26">
      <body>declare is_index boolean := false;
begin
   if context-&gt;'schema' &lt;&gt; 'public' then
      return;
   end if;
   select true
   from 
      pg_index i
      join pg_class ci on ci.oid = i.indexrelid
      join pg_class ct on ct.oid = i.indrelid
   where 
      ct.relname = 'log.$Пользователь' 
      and
      ci.relname = '$ux-hostnameisnull'
      into is_index;
   if ( is_index is distinct from true ) then
      create index "$ux-hostnameisnull" on "log.$Пользователь" ("@$Пользователь") 
         where "ИмяХоста" is null;
   end if;
end</body>
    </callback>
  </converter>

  <converter abstract="0" call_once="1" for_new_db="1" last_changed="Буравлев М.С." name="ИндексНаСубъекта" responsible="Буравлев М.С.">
    <rule name=".*" schema="public" stage="1" type="0"/>
    <callback event="1">
      <body>DECLARE
  cnt int := 0;
  schem text := context-&gt;'schema';
BEGIN
  IF schem IS NOT DISTINCT FROM 'public' THEN
    SELECT
      COUNT( 1 )
    FROM
      pg_index i
    JOIN
      pg_class ix on ix.oid = i.indexrelid
    JOIN
      pg_class t on t.oid = i.indrelid
    WHERE
      t.relname = 'log.$Пользователь' AND ix.relname = '$ux-subj'
    INTO cnt;

    IF cnt IS NOT DISTINCT FROM 0 THEN
      CREATE INDEX "$ux-subj"
        ON "log.$Пользователь"
      USING btree
        ( SUBSTRING("Субъект" FROM '\d+') );
    END IF;

  END IF;
END;</body>
    </callback>
  </converter>

  <converter abstract="0" call_once="1" for_new_db="0" last_changed="Ткачук М.И." name="ИсторияРасширениеИндексов" responsible="Ткачук М.И.">
    <rule name=".*" schema="public" stage="2" type="0"/>
    <callback event="26">
      <body>declare index_fields_count integer := 0;
declare index_name text := null;
begin
   if context-&gt;'schema' &lt;&gt; 'public' then
      return;
   end if;
   select 
      array_length(array_agg(col.attname), 1) as index_columns_count
   from pg_index i
   join pg_class ix on ix.oid = i.indexrelid
   join pg_class t on t.oid = i.indrelid
   join (select ic.indexrelid, 
      unnest(ic.indkey) as colnum
        from pg_index ic) icols on icols.indexrelid = i.indexrelid
   join pg_attribute col on col.attrelid = t.oid and col.attnum = icols.colnum
   where t.relname = 'log.$Пользователь' and ix.relname = '$ux-ipe' into index_fields_count;
   if ( index_fields_count = 3 ) then
      -- пересоздание индекса $ux-ipe;
      drop index "$ux-ipe";
      create unique index "$ux-ipe" on "log.$Пользователь"("IP", "Пользователь", "IPВнутренний", "Субъект", "Сессия");
      -- поиск неименованного индекса
      select ci.relname
      from 
         pg_index i
         join pg_class ci on ci.oid = i.indexrelid
         join pg_class ct on ct.oid = i.indrelid
      where ct.relname = 'log.$Пользователь' 
         and ( (ci.relname like 'log.$Пользователь%' and ci.relname &lt;&gt; 'log.$Пользователь_pkey') or ci.relname = '$ux-unique' ) limit 1 into index_name;
      -- пересоздание неименованного индекса
      if ( index_name is distinct from '$ux-unique' ) then
         if ( index_name is not null ) then
            execute 'drop index ' || '"' || index_name || '"';
         end if;
         create unique index "$ux-unique" on "log.$Пользователь"(
            "Пользователь",
            "IP",
            "IPВнутренний",
            coalesce("Субъект", ''),
            coalesce("Сессия", '')
        );
      end if;
   end if;
end</body>
    </callback>
  </converter>

  <converter abstract="0" call_once="1" for_new_db="1" last_changed="Ткачук М.И." name="ИсторияУникальныйИндекс" responsible="Ткачук М.И.">
    <rule name=".*" schema="public" stage="2" type="0"/>
    <callback event="26">
      <body>declare index_name text := null;
begin
   if context-&gt;'schema' &lt;&gt; 'public' then
      return;
   end if;
   -- поиск уникального индекса
   select ci.relname
   from 
      pg_index i
      join pg_class ci on ci.oid = i.indexrelid
      join pg_class ct on ct.oid = i.indrelid
   where ct.relname = 'log.$Пользователь' 
      and ( (ci.relname like 'log.$Пользователь%' and ci.relname &lt;&gt; 'log.$Пользователь_pkey') or ci.relname = '$ux-unique' ) limit 1 into index_name;
   -- пересоздание неименованного индекса
   if ( index_name is distinct from '$ux-unique' ) then
      if ( index_name is not null ) then
         execute 'drop index ' || '"' || index_name || '"';
      end if;
      create unique index "$ux-unique" on "log.$Пользователь"(
         "Пользователь",
         "IP",
         "IPВнутренний",
         coalesce("Субъект", ''),
         coalesce("Сессия", '')
     );
   end if;
end</body>
    </callback>
  </converter>

  <converter abstract="0" call_once="1" for_new_db="0" last_changed="Ткачук М.И." name="РасширениеТаблицЛоггирования" responsible="Ткачук М.И.">
    <rule name=".*" schema="public" stage="0" type="0"/>
    <callback event="1">
      <body>declare subject_field text := null;
declare session_field text := null;
begin
   if context-&gt;'schema' &lt;&gt; 'public' then
      return;
   end if;
-- Проверка поля Субъект
   select at.attname
   from pg_attribute at inner join pg_type tp on at.atttypid = tp.oid 
   where at.attrelid = 'public."log.$Пользователь"'::regclass and at.attnum &gt; 0 and not at.attisdropped and at.attname = 'Субъект' into subject_field;
   if (subject_field is null) then
      alter table "log.$Пользователь" add column "Субъект" 
         text DEFAULT cfg('subjectID');
   end if;
-- Проверка поля Сессия   
   select at.attname
   from pg_attribute at inner join pg_type tp on at.atttypid = tp.oid 
   where at.attrelid = 'public."log.$Пользователь"'::regclass and at.attnum &gt; 0 and not at.attisdropped and at.attname = 'Сессия' into session_field;
   if (session_field is null) then
      alter table "log.$Пользователь" add column "Сессия"
         text DEFAULT cfg('sessionID');
   end if;
end</body>
    </callback>
  </converter>

</converter_library>
